=begin

  Automates many rogue guild tasks. Currently automates all solo sweep, gambit, cheap shot and subdue tasks. Can also automate critter sweep tasks.
  In order to automate sweep, gambit and cheap shot partner reps you and your partner must have both this script and the "task" script.

  Must do ;rogue setup and fill out the settings before running this script.

  Type ;rogue for usage.

  Type ;rogue sweep to automate solo sweep tasks. ;rogue sweep <partnername> for partner tasks.
  Type ;rogue gam to automate solo gambit tasks. ;rogue gam <partnername> for partner tasks.
  Type ;rogue cheap to automate solo cheap shot tasks. ;rogue cheap <partnername> for partner tasks.
  Type ;rogue sub to automate solo subdue tasks.
  Type ;rogue lmas to do lockmastery tasks. Doesn't do all lockmastery tasks.
  Type ;rogue stun to do stun maneuvers tasks. Currently only does sweep courtyard and clean windows tasks.
  Typing ;rogue <sweep, gam, sub or lmas> will also turn in completed tasks to the NPC.
  Type ;rogue cal to calibrate your calipers.
  Type ;rogue wedge <number> to create specified number of wedges.
  Note: do not type GLD while script is running, it could make the script stop working.

  Remember afk scripting is a no no in prime/platnium so pay attention to your game screen while running this script.
  Kill this script if going afk.

  Author:  Tgo01
  Version:  40

=end
version = 40

wander_rooms = Array.new
weapon = UserVars.rogue["task_weapon"]
stow_container = UserVars.rogue["stow_container"]
wedge_container = UserVars.rogue["wedge_container"]
calipers_container = UserVars.rogue["calipers_container"]
lockpick_container = UserVars.rogue["lockpick_container"]
mainweapon = UserVars.rogue["mainweapon"]
shield = UserVars.rogue["shield"]
auto_promote = UserVars.rogue["auto_promote"]
update_partner = UserVars.rogue["update_partner"]
lock_create_number = UserVars.rogue["lock_create_number"]
auto_run_after_partner_reps = UserVars.rogue["auto_run_after_partner_reps"]
do_other_guild_tasks = UserVars.rogue["do_other_guild_tasks"]
lmas_lockpick = UserVars.rogue["lmas_lockpick"]
do_critter_sweep_tasks = UserVars.rogue["do_critter_sweep_tasks"]
$stealth_get_item = UserVars.rogue["stealth_get_item"]
$stealth_get_item_container = UserVars.rogue["stealth_get_item_container"]
gam = UserVars.rogue["gambit"]
flee_from_critters = /#{UserVars.rogue["flee_from_critters"]}/i
valid_critter_targets = /#{UserVars.rogue["valid_critter_targets"]}/i
flee_from_critters_count = UserVars.rogue["flee_from_critters_count"].to_i
critter_task_rooms = "#{UserVars.rogue["critter_task_rooms"]}".split(",")
partner_room_number = UserVars.rogue["partner_room_number"]
lich_message_partner = UserVars.rogue["lich_message_partner"]
numberoflockpicks = nil
current_window_rooms = nil
get_item_trick = nil
hide_before_trick = nil
CharSettings['setup_has_been_run'] = nil unless CharSettings['setup_has_been_run']

setup = proc{
  CharSettings['setup_has_been_run'] = true
  Gtk.queue {
    $AAA_WINDOW = Gtk::Window.new
    $AAA_WINDOW.set_icon(@@default_icon)
    $AAA_WINDOW.title = "rogue"
    $AAA_WINDOW.set_border_width(10)
    $AAA_BOX = Gtk::Box.new(:vertical)
    $AAA_BOX.set_border_width(5)

    $AAA_VERTICAL_BOX1 = Gtk::Box.new(:vertical, 0)
    $AAA_VERTICAL_BOX2 = Gtk::Box.new(:vertical, 0)
    $AAA_VERTICAL_BOX3 = Gtk::Box.new(:vertical, 0)
    $AAA_VERTICAL_BOX4 = Gtk::Box.new(:vertical, 0)
    $AAA_VERTICAL_BOX5 = Gtk::Box.new(:vertical, 0)

    $AAA_WINDOW.add($AAA_BOX)
    $AAA_NOTEBOOK = Gtk::Notebook.new
    $AAA_NOTEBOOK.set_show_border(true)
    $AAA_BOX.add($AAA_NOTEBOOK)
    $AAA_NOTEBOOK.append_page($AAA_VERTICAL_BOX1, Gtk::Label.new('Info'))
    $AAA_NOTEBOOK.append_page($AAA_VERTICAL_BOX2, Gtk::Label.new('More Info'))
    $AAA_NOTEBOOK.append_page($AAA_VERTICAL_BOX3, Gtk::Label.new('Gambits'))
    $AAA_NOTEBOOK.append_page($AAA_VERTICAL_BOX4, Gtk::Label.new('Sweep'))
    $AAA_NOTEBOOK.append_page($AAA_VERTICAL_BOX5, Gtk::Label.new('Partner Info'))
    $AAA_ENTRY = Hash.new
    $AAA_TABLE_SIZE = Hash.new
  }

  Gtk.queue {
    $AAA_TABLE1 = Gtk::Table.new(6, 3, false)
    $AAA_TABLE1.row_spacings=3
    $AAA_TABLE1.column_spacings=3
    $AAA_VERTICAL_BOX1.pack_start($AAA_TABLE1, :expand => false, :fill => false, :padding => 0)

    $AAA_TABLE2 = Gtk::Table.new(6, 3, false)
    $AAA_TABLE2.row_spacings=3
    $AAA_TABLE2.column_spacings=3
    $AAA_VERTICAL_BOX2.pack_start($AAA_TABLE2, :expand => false, :fill => false, :padding => 0)

    $AAA_TABLE3 = Gtk::Table.new(6, 3, false)
    $AAA_TABLE3.row_spacings=3
    $AAA_TABLE3.column_spacings=3
    $AAA_VERTICAL_BOX3.pack_start($AAA_TABLE3, :expand => false, :fill => false, :padding => 0)

    $AAA_TABLE4 = Gtk::Table.new(6, 3, false)
    $AAA_TABLE4.row_spacings=3
    $AAA_TABLE4.column_spacings=3
    $AAA_VERTICAL_BOX4.pack_start($AAA_TABLE4, :expand => false, :fill => false, :padding => 0)

    $AAA_TABLE5 = Gtk::Table.new(6, 3, false)
    $AAA_TABLE5.row_spacings=3
    $AAA_TABLE5.column_spacings=3
    $AAA_VERTICAL_BOX5.pack_start($AAA_TABLE5, :expand => false, :fill => false, :padding => 0)
  }

  def self.add_label_entry(table, label, variable)
    size = $AAA_TABLE_SIZE[table] || 0

    label = Gtk::Label.new(label)
    align = Gtk::Alignment.new 1, 0, 0, 0
    align.set_padding(4, 0, 3, 4)
    align.add(label)
    table.attach(align, 0, 1, size, size + 1)

    entry = Gtk::Entry.new
    entry.text = UserVars.rogue[variable].to_s
    entry.set_width_request(157)
    table.attach(entry, 1, 2, size, size + 1)

    $AAA_ENTRY[variable] = entry
    $AAA_TABLE_SIZE[table] += 1
  end

  Gtk.queue {
    $AAA_ENTRY = Hash.new
    add_label_entry($AAA_TABLE1, "Task weapon:", 'task_weapon')
    add_label_entry($AAA_TABLE1, "Stow container:", 'stow_container')
    add_label_entry($AAA_TABLE1, "Wedge container:", 'wedge_container')
    add_label_entry($AAA_TABLE1, "Calipers container:", 'calipers_container')
    add_label_entry($AAA_TABLE1, "Lockpick container:", 'lockpick_container')
    add_label_entry($AAA_TABLE1, "Main weapon:", 'mainweapon')
    add_label_entry($AAA_TABLE1, "Shield/offhand:", 'shield')
    add_label_entry($AAA_TABLE2, "Auto promote:", 'auto_promote')
    add_label_entry($AAA_TABLE2, "Update partner:", 'update_partner')
    add_label_entry($AAA_TABLE2, "Lock create number:", 'lock_create_number')
    add_label_entry($AAA_TABLE2, "Auto run after partner reps:", 'auto_run_after_partner_reps')
    add_label_entry($AAA_TABLE2, "Do other guild tasks:", 'do_other_guild_tasks')
    add_label_entry($AAA_TABLE2, "Lmas lockpick:", 'lmas_lockpick')
    add_label_entry($AAA_TABLE2, "Do critter sweep tasks", 'do_critter_sweep_tasks')
    add_label_entry($AAA_TABLE3, "Stealth get item:", 'stealth_get_item')
    add_label_entry($AAA_TABLE3, "Stealth get item container:", 'stealth_get_item_container')
    add_label_entry($AAA_TABLE3, "Gambit:", 'gambit')
    add_label_entry($AAA_TABLE4, "Flee from critters:", 'flee_from_critters')
    add_label_entry($AAA_TABLE4, "Valid critter targets:", 'valid_critter_targets')
    add_label_entry($AAA_TABLE4, "Flee from critters count:", 'flee_from_critters_count')
    add_label_entry($AAA_TABLE4, "Critter rooms:", 'critter_task_rooms')
    add_label_entry($AAA_TABLE5, "Partner room number:", 'partner_room_number')
    add_label_entry($AAA_TABLE5, "Lich message partner:", 'lich_message_partner')

  }

  def self.add_checkbox(table, x_pos, label, variable, default = false)
    size = $AAA_TABLE_SIZE[table] || 0
    checkbox = Gtk::CheckButton.new label
    value = UserVars.rogue[variable].nil? ? default : UserVars.rogue[variable]
    checkbox.set_active(value)
    table.attach(checkbox, x_pos, x_pos + 1, size, size + 1)
    $AAA_ENTRY[variable] = checkbox
    $AAA_TABLE_SIZE[table] += 1 if x_pos == 1
  end

  Gtk.queue {
    $AAA_WINDOW.signal_connect("delete_event") {
      $AAA_SETUP_COMPLETED = true
    }
  }

  Gtk.queue {
#   $AAA_TOOLTIPS = Gtk::Tooltips.new
#   $AAA_TOOLTIPS.enable

    label = Gtk::Label.new
    label.set_markup("Enter <b>nil</b> for any setting you don't want to use.\n<b>Task weapon:</b> Name of weapon you use for tasks.\n<b>Stow container:</b>  Container name for where you stow things. Do NOT use same container you keep your lockpicks in, this might end up throwing them away.\n<b>Wedge container:</b>  Name of container where your wedges are stored.\n<b>Calipers container:</b>  Name of container where your calipers are stored.\n<b>Lockpick container:</b>  Name of container where your lockpicks are stored.\n<b>Main weapon:</b>  Name of weapon you use for hunting/DS.\n<b>Shield/offhand:</b>  Name of shield/offhand weapon you use for hunting/DS.")
    align = Gtk::Alignment.new(1, 0, 0, 0)
    align.set_padding(50, 0, 0, 40)
    align.add(label)
    $AAA_TABLE1.attach(align, 1, 2, 8, 9)

    label = Gtk::Label.new
    label.set_markup("Enter <b>nil</b> for any setting you don't want to use.\n<b>Auto promote:</b>  Enter <b>on</b> to have script automatically receive promotions from NPC guildmaster.\n<b>Update partner:</b>  Enter <b>on</b> to whisper your partner how many reps you have left after each successful rep.\n<b>Lock create number:</b>  Difficulty level of locks to create for non master create lock reps.\n<b>Auto run after partner reps:</b>  Enter <b>yes</b> to automatically turn in partner tasks as soon as they are finished.\n<b>Do other guild tasks:</b>  Enter <b>yes</b> to automatically go to other guilds to finish window and water plants tasks.\n<b>Lmas lockpick:</b>  Name of your best lockpick, for example <b>vaalin lockpick</b>\n<b>Do critter sweep tasks:</b>  Enter <b>yes</b> if you want to do these tasks manually, <b>no</b> if you want the script to turn these tasks in and continue on, <b>auto</b> if you want the script to automatically finish these tasks.")
    align = Gtk::Alignment.new(1, 0, 0, 0)
    align.set_padding(50, 0, 0, 40)
    align.add(label)
    $AAA_TABLE2.attach(align, 1, 2, 8, 9)

    label = Gtk::Label.new
    label.set_markup("Enter <b>nil</b> for any setting you don't want to use.\n<b>Stealth get item:</b>  Name of item to use during <b>stealth get gambits.</b>  NOTE This item will be dropped on the ground, don't use an item you don't want to lose.\n<b>Stealth get item container:</b>  Container where your <b>stealth get item</b> is stored.\n<b>Gambit:</b>  Enter what you type to do your current gambit; do not include the word 'rgambit' and don't abbreviate any words.\nIf doing the stealth get gambit then the <b>Gambit</b> setting should be: stealth get # $stealth_get_item (without the space between # and $)")
    align = Gtk::Alignment.new(1, 0, 0, 0)
    align.set_padding(50, 0, 0, 40)
    align.add(label)
    $AAA_TABLE3.attach(align, 1, 2, 8, 9)


    label = Gtk::Label.new
    label.set_markup("Enter <b>nil</b> for any setting you don't want to use.\n<b>These settings are only required if you're having the script automatically do sweep critter tasks.</b>\n<b>Flee from critters:</b>  Name of critters to always flee from. Seperate each name with a |. Example kobold|orc|rolton\n<b>Valid critter targets:</b>  Name of critters to sweep. Same as above for more than one critter.\n<b>Flee from critters count:</b>  Will flee from current room if number of critters is this amount of higher.\n<b>Critter rooms:</b>  List all rooms of area you want to look for critters in; example 1,2,3\nNo spaces after commas.\n")
    align = Gtk::Alignment.new(1, 0, 0, 0)
    align.set_padding(50, 0, 0, 40)
    align.add(label)
    $AAA_TABLE4.attach(align, 1, 2, 8, 9)

    label = Gtk::Label.new
    label.set_markup("Fill these settings out if you are running with a dedicated partner who is also running the <b>rogue</b> and <b>task</b> scripts and is going to help you automate through partner tasks.\nEnter <b>nil</b> for each setting if you are not running with such a partner or if you don't want to use a particular setting.\n<b>Partner room number:</b>  Room number where you and your partner will meet to do partner tasks.\n<b>Lich message partner:</b>  Enter <b>yes</b> to send a lnet message to your partner when you need them for a partner task.\nThe lnet message is just to inform your partner when you need their help in the room you specified for partner tasks, it does not make your partner move or run any scripts even if they are currently running <b>rogue</b> and <b>task</b>.")
    align = Gtk::Alignment.new(1, 0, 0, 0)
    align.set_padding(50, 0, 0, 40)
    align.add(label)
    $AAA_TABLE5.attach(align, 1, 2, 8, 9)

    $AAA_WINDOW.show_all
  }

  $AAA_SETUP_COMPLETED = false
  until($AAA_SETUP_COMPLETED)
    sleep 1
  end

  UserVars.rogue ||= Hash.new
  $AAA_ENTRY.keys.each { |key|
    if( $AAA_ENTRY[key].class.to_s =~ /CheckButton/ )
      value = $AAA_ENTRY[key].active?
      UserVars.rogue[key] = $AAA_ENTRY[key].active?
    else
      if(key == 'wounded_eval')
        UserVars.rogue[key] = $AAA_ENTRY[key].text
      else
        UserVars.rogue[key] = $AAA_ENTRY[key].text.strip.downcase
      end
    end
  }
  UserVars.save()

  Gtk.queue {
    $AAA_WINDOW.destroy
  }
}

flower = nil
icedirt_rooms = [ '17972', '17966', '17965', '17976' ]
landingdirt_rooms = [ '16517', '16490', '16438', '16492', '16534', '16540' ]
soldirt_rooms = [ '17949', '17948', '17947', '17946', '17942', '17944', '17945' ]
illistim_dirt_rooms = [ '17840', '17876', '17877', '17879', '17878' ]
icewindow_rooms = [ '17975', '17966', '17965', '17976', '17964' ]
landingwindow_rooms = [ '16557', '16555', '16491', '16490', '16517' ]
solwindow_rooms = [ '17950', '17948', '17946', '17944', '17963' ]
illistimwindow_rooms = [ '17871', '17872', '17853', '17860', '17869' ]
iceplant_rooms = [ '17974', '17965', '17967', '17976', '17964' ]
landingplant_rooms = [ '16545', '16504', '16438', '16534', '16517' ]
solplant_rooms = [ '17953', '17950', '17946', '17942', '17944' ]
illistimplant_rooms = [ '17871', '17851', '17855', '17869', '17870' ]
audience_rooms = [ '2300', '228', '188' ]
training_administrator_room = [ '17967', '16504', '17948', '17798', '17883' ]
toolbenches_room_number = [ '17978', '16574', '17960', '17881' ]
guild_master_room_number = [ '17975', '16485', '17956', '17886' ]
training_master_room_number = [ '17965', '16540', '17951', '17419', '17864' ]
sweeping_dummies_room_number = [ '17976', '16509', '17950', '17862' ]
kitchen_room_number = [ '17969', '16433', '17940', '17889' ]
mannequin_room_number = [ '17965', '16509', '17949', '17861' ]
tool_rack_room_number = [ '17969', '16581', '17941', '17861' ]
training_administrator_names = /teagais|deluca|milgrew|runaire|boucher/i
guild_master_names = /kuidich|dante|lindil|lydon/i
master_names = /duchel|palder|meallan|miller|bean|reilly|varant|triaholly|sneck|jimik|herit|lagick|zardak|faldes|gludac|vigil|ritchie|colvin|purkhiser/i
flower_names = /wildflower|iceflower|dandelion|begonia|iris|rose|wisteria/i
(stand_up = nil;stamina_check = nil;my_room = nil;other_players = nil;other_players_disks = nil;wander = nil;auto_critter_sweep_tasks = nil;critter_target = nil;get_critter_target = nil;dangerous_critter_found = 0;npcs_alive = nil;critter_count = 0;get_critter_target = nil;dangerous_critter_found = 0;getpick = nil;checkin = nil;person = nil;help_sweep_partner_start = nil;help = nil;help_cheap_partner_start = nil;go_to_task = nil;stow = nil;gam_teach_help_start = nil;gam_learn_help_start = nil;gam_teach_help_start1 = nil;gam_learn_help_start2 = nil;gam_learn_help_start3 = nil;sweepstart = nil;sweep_partner = nil;sweep_defend = nil;sweep_master = nil;sweep_dummies = nil;sweep_dirt = nil;sweep_critters = nil;promotion = nil;partner_room = nil;sweep_partner_start = nil;auto_run = nil;sweep_defend_start = nil;reps = nil;sweep_master_begin = nil;sweep_master_start = nil;promotion = nil;number = nil;sweep_dummy_start = nil;sweep_dirt_move = nil;sweep_dirt_sweep = nil;sweep_dirt_get = nil;sweep_dirt_full = nil;garlic_start = nil;mannequins_start = nil;windows_get_rag = nil;sub_critters = nil;get_garlic = nil;mannequins_subdue = nil;windows_move = nil;windows_clean = nil;go_to_room = nil;lmas_tough_boxes = nil;lmas_trick = nil;keys = nil;lmas_footpad_talk = nil;lmas_footpad_challenge = nil;customize = nil;lmas_footpad_lock_start = nil;lmas_lockpick_start = nil;customize_footpad_pre = nil;customize_create = nil;customize_footpad_create = nil;customize_footpad_finished = nil;customize_footpad_hand_in1 = nil;lmas_footpad_lock_start = nil;lmas_footpad_challenge_begin = nil;lmas_footpad_challenge_begin1 = nil;lmas_footpad_challenge_wait = nil;lmas_footpad_challenge_trap = nil;lmas_footpad_challenge_pick = nil;lmas_footpad_challenge1 = nil;cal = nil;cal_start = nil;carve_go = nil;buy_block = nil;carve_start = nil;carve = nil;carve_rub = nil;lock_pick_create = nil;lockpick_handin = nil;lockpick_handin1 = nil;gam_learn_start = nil;gam_audience_start = nil;gam_speed_start = nil;gam_teach_start = nil;gam_learn_start1 = nil;gam_learn_start2 = nil;gam_audience_start1 = nil;gam_speed_begin = nil;gam_teach_start1 = nil;repair = nil;keys_1 = nil;footstomp_defend = nil;footstomp_partner = nil;cheap_critter = nil;cheap_plants = nil;foot_stomp_defend1 = nil;footstomp_partner_start = nil;cheap_plants_move = nil;cheap_plants_water = nil;cheapstart = nil;substart = nil;lmasstart = nil;gamstart = nil;master = nil;stunstart = nil)
target_room = nil
dirt_rooms = nil
talk_to_footpad_masters = nil
current_plant_rooms = nil

box = ["filler",
  "first box",
  "second box",
  "third box",
  "fourth box",
  "fifth box"
  ]

Pick = ["red lockpick", "steel lockpick", "gold lockpick", "silver lockpick", "ora lockpick", "mithril lockpick", "scrimshaw lockpick", "laje lockpick", "vultite lockpick", "rolaren lockpick", "veniom lockpick", "invar lockpick", "alum lockpick", "golvern lockpick", "kelyn lockpick", "vaalin lockpick", "cast"]
$lockpick_number = 0

getpick = proc{
  exit if $lockpick_number >= 16
  multifput "get my #{Pick[$lockpick_number]} from my keyring", "lmas app my lock"
  while line = get
    if line =~ /It appears to be broken/
      wire = 2 if $lockpick_number == 0
      wire = 4 if $lockpick_number == 1
      wire = 5 if $lockpick_number == 2
      wire = 6 if $lockpick_number == 3
      wire = 7 if $lockpick_number == 4
      wire = 8 if $lockpick_number == 5
      wire = 9 if $lockpick_number == 7
      wire = 11 if $lockpick_number == 8
      wire = 12 if $lockpick_number == 9
      wire = 13 if $lockpick_number == 10
      wire = 15 if $lockpick_number == 11
      wire = 10 if $lockpick_number == 12
      wire = 16 if $lockpick_number == 13
      wire = 14 if $lockpick_number == 14
      wire = 17 if $lockpick_number == 15
      multifput "order #{wire}", "buy", "lmas repair my lock"
      waitrt?
      fput "lmas repair my lock"
      waitrt?
      fput "put my lockpick in my keyring"
      $lockpick_number = $lockpick_number + 1
      getpick.call
    elsif line =~ /You could probably handle/
      fput "lmas repair my lock"
      waitrt?
      fput "put my lockpick in my keyring"
      $lockpick_number = $lockpick_number + 1
      getpick.call
    end
  end
}

stand_up = proc{
  (waitrt?;fput "stand";sleep 0.1) until standing?
}

stamina_check = proc{
  if checkstamina < 12
    echo "Waiting for stamina."
    wait_until{ checkstamina >= 12 }
  end
}

auto_run = proc{
  if auto_run_after_partner_reps == "yes"
    turnin.call
  else
    exit
  end
}

turnin = proc{
  stand_up.call if !standing?
  waitrt?
  move 'out' if checkpaths 'out'
  target_room = Room.current.find_nearest(training_administrator_room)
  start_script 'go2', [ target_room.to_s ]
  wait_while{ running?('go2') }
  GameObj.npcs.find { |npc| person = npc if npc.name =~ training_administrator_names }
  multifput "ask #{person} about train #{script.vars[1]}", "ask #{person} about train #{script.vars[1]}"
  go_to_task.call
}

promotion = proc{
  if auto_promote == "on"
    move 'out' if checkpaths 'out'
    target_room = Room.current.find_nearest(guild_master_room_number)
    start_script 'go2', [ target_room.to_s ]
    wait_while{ running?('go2') }
    GameObj.npcs.find { |npc| person = npc if npc.name =~ guild_master_names }
    fput "ask #{person} about next #{script.vars[1]}"
    target_room = Room.current.find_nearest(training_administrator_room)
    start_script 'go2', [ target_room.to_s ]
    wait_while{ running?('go2') }
    GameObj.npcs.find { |npc| person = npc if npc.name =~ training_administrator_names }
    fput "ask #{person} about train #{script.vars[1]}"
    go_to_task.call
  else
    exit
  end
}

wander = proc{
  sleep 0.1
  room = Room.current
  acceptable_adjacent_rooms = room.wayto.keys & critter_task_rooms
  not_visited_rooms = acceptable_adjacent_rooms.find_all { |r| not wander_rooms.include?(r) }
  if not_visited_rooms.empty?
    next_room = wander_rooms.find { |r| acceptable_adjacent_rooms.include?(r) }
  else
    next_room = not_visited_rooms[rand(not_visited_rooms.length)]
  end
  if next_room
    wander_rooms.delete(next_room)
    wander_rooms.push(next_room)
    way = room.wayto[next_room]
    if way.class == String
      move(way)
      my_room = nil
      critter_target = nil
      other_players = nil
      other_players_disks = nil
      other_players = checkpcs.each { |pc| i += 1; break if pc == Char.name }
      (wander.call) if other_players != nil
      other_players_disks = GameObj.loot.find { |obj| (obj.noun == 'disk') and (obj.name !~ /#{checkname}/) }
      (wander.call) if other_players_disks != nil
      my_room = Room.current.id
    else
      way.call
      my_room = nil
      critter_target = nil
      other_players = nil
      other_players_disks = nil
      other_players = checkpcs.each { |pc| i += 1; break if pc == Char.name }
      (wander.call) if other_players != nil
      other_players_disks = GameObj.loot.find { |obj| (obj.noun == 'disk') and (obj.name !~ /#{checkname}/) }
      (wander.call) if other_players_disks != nil
      my_room = Room.current.id
    end
  else
    start_script 'go2', [ Room.current.find_nearest(critter_task_rooms.collect { |id| id.to_i }).to_s ]
    wait_while { running?('go2') }
      my_room = nil
      critter_target = nil
      other_players = nil
      other_players_disks = nil
      other_players = checkpcs.each { |pc| i += 1; break if pc == Char.name }
      (wander.call) if other_players != nil
      other_players_disks = GameObj.loot.find { |obj| (obj.noun == 'disk') and (obj.name !~ /#{checkname}/) }
      (wander.call) if other_players_disks != nil
      my_room = Room.current.id
  end
}

partner_room = proc{
  if partner_room_number != "nil"
    LNet.send_message(h={'to'=>"#{my_partner}", 'type'=>'private'}, "I need your help with a guild task.") if lich_message_partner == "yes"
    if Room.current.id != Integer(partner_room_number)
      move 'out' if checkpaths 'out'
      start_script "go2", [partner_room_number]
      wait_while{ running?('go2') }
    end
  end
}

get_critter_target = proc{
  critter_target = GameObj.npcs.find { |npc| npc.name =~ valid_critter_targets and npc.status !~ /dead|gone|prone|sit|kneel/ }
  if critter_target == nil
    wander.call
  end
}

auto_critter_sweep_tasks = proc{
  loop{
    if critter_target.status =~ /dead|gone|prone|sit|kneel/
      critter_target = nil
    end
    if !standing?
      until standing?
        waitrt?
        fput "stand"
        sleep 0.5
      end
    end
    if checkstance != "defensive"
      waitrt?
      fput "stance def"
    end
    if checkstamina < 12
      echo "Waiting for stamina."
      wait_until{ checkstamina >= 12 }
    end
    if my_room != Room.current.id
      critter_target = nil
      my_room = nil
      wander.call
      redo
    end
    if critter_target == nil and my_room == Room.current.id
      critter_target = nil
      get_critter_target.call
      redo
    end
    npcs_alive = nil
    npcs_alive = GameObj.npcs.find_all { |i| i.status != 'dead' }
    npcs_alive.each { critter_count = critter_count + 1 }
    if critter_count > flee_from_critters_count
      (critter_count = 0;dangerous_critter_found = 0;npcs_alive = nil;wander.call;redo)
    end
    GameObj.npcs.each { |i| dangerous_critter_found = 1 if i.name =~ flee_from_critters and i.status != 'dead' }
    if dangerous_critter_found == 1
      (dangerous_critter_found = 0;critter_count = 0;wander.call;redo)
    end
    if critter_target != nil and critter_target.status !~ /dead|gone|prone|sit|kneel/ and my_room == Room.current.id
      fput "stance off"
      result = dothistimeout "sweep #{critter_target}", 3, /You have completed/i
      if result =~ /You have completed/i
        (turnin.call)
      elsif result.nil?
        redo
      end
    end
    sleep 0.1
  }
}

stow = proc{
  fput "stow left" if checkleft != nil
  fput "stow right" if checkright != nil
}

go_to_task = proc{
  if script.vars[1] == "sweep"
    sweepstart.call
  elsif script.vars[1] == "gam"
    gamstart.call
  elsif script.vars[1] == "cheap"
    cheapstart.call
  elsif script.vars[1] == "lmas"
    lmasstart.call
  elsif script.vars[1] == "sub"
    substart.call
  elsif script.vars[1] == "stun"
    stunstart.call
  end
}

checkin = proc{
  move 'out' if checkpaths 'out'
  target_room = Room.current.find_nearest(guild_master_room_number)
  start_script 'go2', [ target_room.to_s ]
  wait_while{ running?('go2') }
  GameObj.npcs.find { |npc| person = npc if npc.name =~ guild_master_names }
  fput "ask #{person} about checkin"
  exit
}

help_sweep_partner_start = proc{
  stand_up.call if !standing?
  stamina_check.call if checkstamina < 12
  waitrt?
  result = dothistimeout "sweep #{script.vars[3]}", 3, /is already prone|(You might want to stand up first.|Roundtime)/i
  if result =~ /is already prone/i
    fput "pull #{script.vars[3]}"
    help_sweep_partner_start.call
  elsif result =~ /(You might want to stand up first.|Roundtime)/i
    help_sweep_partner_start.call
  elsif result.nil?
    help_sweep_partner_start.call
  end
}

help_cheap_partner_start = proc{
  stand_up.call if !standing?
  stamina_check.call if checkstamina < 12
  waitrt?
  result = dothistimeout "cheap foot #{script.vars[3]}", 2, /just fell for a footstomp not long ago/i
  if result =~ /just fell for a footstomp not long ago/
    sleep 2
    help_cheap_partner_start.call
  elsif result.nil?
    sleep 13
    help_cheap_partner_start.call
  end
}

gam_teach_help_start = proc{
  stow.call
  waitfor "I am ready to learn"
  partner = GameObj.pcs.find { |pc| pc.name =~ /#{script.vars[3]}(.*)/i }
  gam_teach_help_start1.call
}

gam_teach_help_start1 = proc{
  if $task =~ /stealth/i
    if $task =~ /stand/i
      wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{partner}/i and partner.status =~ /kneel/ } }
    else
      wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{partner}/i and partner.status.nil? } }
    end
  end
  waitrt?
  result = dothistimeout "#$task", 5, /You need to have free hands to teach this gambit|You already have that|You should have a silver coin on you to teach this gambit|Wait a few seconds and try again|You need to be holding something first|Who are you trying to teach/i
  if result =~ /You need to have free hands to teach this gambit/i
    stow.call
    gam_teach_help_start1.call
  elsif result =~ /You already have that/i
    fput "stow #{weapon}"
    gam_teach_help_start1.call
  elsif result =~ /You should have a silver coin on you to teach this gambit/i
    fput "whisper #{script.vars[3]} Need a coin, be right back."
    currentroom = Room.current.id
    start_script 'go2', [ 'bank', '--disable-confirm' ]
    wait_while{ running?('go2') }
    fput "withdraw 2 silvers"
    start_script "go2", [ "#{currentroom}" ]
    wait_while{ running?('go2') }
    gam_teach_help_start1.call
  elsif result =~ /Wait a few seconds and try again/i
    sleep 2
    gam_teach_help_start1.call
  elsif result =~ /You need to be holding something first/
    fput "get my #{weapon}"
    gam_teach_help_start1.call
  elsif result =~ /Who are you trying to teach/
    sleep 2
    gam_teach_help_start1.call
  elsif result.nil?
    gam_teach_help_start1.call
  end
}

gam_learn_help_start = proc{
  stow.call
  fput "#$task"
  if $task =~ /stealth/i
    hide_before_trick = "yes"
  end
  if $task =~ /get/i
    get_item_trick = "yes"
  end
  if get_item_trick == "yes"
    multifput "get my #$stealth_get_item from my #$stealth_get_item_container", "drop my #$stealth_get_item"
  end
  until !hiding?
    waitrt?
    fput "unhide"
  end
  if $task =~ /stealth/i
    if $task =~ /stand/i
      until kneeling?
        waitrt?
        fput "kneel"
        sleep 0.1
      end
    else
      until standing?
        waitrt?
        fput "stand"
        sleep 0.1
      end
    end
  end
  waitrt?
  fput "whisper #{script.vars[3]} I am ready to learn"
  gam_learn_help_start2.call
}

gam_learn_help_start2 = proc{
  waitrt?
  until !hiding?
    waitrt?
    fput "unhide"
    sleep 0.1
  end
  if $task =~ /stealth/i
    if $task =~ /stand/i
      until kneeling?
        waitrt?
        fput "kneel"
        sleep 0.1
      end
    else
      until standing?
        waitrt?
        fput "stand"
        sleep 0.1
      end
    end
  end
  waitrt?
  if get_item_trick == "yes"
    waitfor "shows you how to take an item from the ground without giving yourself away"
  elsif hide_before_trick == "yes"
    waitfor "gives you some pointers"
  end
  gam_learn_help_start3.call
}

gam_learn_help_start3 = proc{
  waitrt?
  until !hiding?
    waitrt?
    fput "unhide"
    sleep 0.1
  end
  if $task =~ /stealth/i
    if $task =~ /stand/i
      until kneeling?
        waitrt?
        fput "kneel"
        sleep 0.1
      end
    else
      until standing?
        waitrt?
        fput "stand"
        sleep 0.1
      end
    end
  end
  waitrt?
  if get_item_trick == "yes"
    fput "drop my #$stealth_get_item"
  end
  if hide_before_trick == "yes"
    until hiding?
      waitrt?
      fput "hide"
      sleep 0.1
    end
  end
  waitrt?
  result = dothistimeout "#$task", 5, /You need to be holding something first|You already have that|Just how stealthy are you trying to be|but realize that doing so would reveal your location|suddenly become aware that your actions have revealed your location|Roundtime|You manage to move to|keeping your location hidden|but have revealed yourself from hiding in doing so|but realize that doing so would compromise your hidden position/i
  if result =~ /You need to be holding something first/i
    fput "get my #{weapon}"
    gam_learn_help_start2.call
  elsif result =~ /You already have that/i
    fput "stow #{weapon}"
    gam_learn_help_start2.call
  elsif result =~ /Roundtime|You manage to move to|keeping your location hidden/i
    gam_learn_help_start2.call
  elsif result =~ /Just how stealthy are you trying to be/i
    gam_learn_help_start3.call
  elsif result =~ /suddenly become aware that your actions have revealed your location|but realize that doing so would reveal your location/i
    gam_learn_help_start2.call
  elsif result =~ /but have revealed yourself from hiding in doing so/i
    if get_item_trick == "yes"
      fput "drop my #$stealth_get_item"
      gam_learn_help_start3.call
    end
  elsif result =~ /but realize that doing so would compromise your hidden position/i
    gam_learn_help_start3.call
  elsif result.nil?
    gam_learn_help_start3.call
  end
}

sweepstart = proc{
  stow.call
  fput "gld"
  waitfor "Sweep skill"
  while line = get
    (sweep_partner.call;break) if line =~ /The Training Administrator told you to practice sweeping a partner./i
    (sweep_defend.call;break) if line =~ /The Training Administrator told you to defend against a partner./i
    (sweep_master.call;break) if line =~ /The Training Administrator told you to get some lessons from the footpads./i
    (sweep_dummies.call;break) if line =~ /The Training Administrator told you to work out on the sweep dummies./i
    (sweep_dirt.call;break) if line =~ /The Training Administrator told you to sweep the guild courtyard./i
    (sweep_critters.call;break) if line =~ /The Training Administrator told you to practice sweeping creatures./i
    (promotion.call;break) if line =~ /(Congratulations, you've earned a rank|You need to get promoted to your next rank in Sweep|You have earned enough training points for your next rank.)/i
    (turnin.call;break) if line =~ /You are not currently training in this skill/i
  end
}

stunstart = proc{
  stow.call
  fput "gld"
  waitfor "Stun Maneuvers skill"
  while line = get
    if line =~ /The Training Administrator told you to sweep the guild courtyard\./
      sweep_dirt.call
      break
    elsif line =~ /The Training Administrator told you to clean the windows in the guild\.|The Training Administrator told you to clean the guild windows\./
      windows_get_rag.call
      break
    end
  end
}

sweep_partner = proc{
  fput "gld"
  waitfor "The Training Administrator told you to practice sweeping a partner"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      multifput "gld stance off", "stance off"
      partner_room.call
      wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i } }
      fput "whisper #{my_partner} I need to sweep you."
      waitfor "Ready to be swept"
      sweep_partner_start.call
      break
    end
  end
}

sweep_partner_start = proc{
  stand_up.call if !standing?
  stamina_check.call if checkstamina < 12
  waitrt?
  result = dothistimeout "sweep #{my_partner}", 3, /You have completed your training task.|is already prone|You might want to stand up first.|Sweep what\?|repetition|Roundtime/i
  if result =~ /You have completed your training task./i
    waitrt?
    fput "pull #{my_partner}"
    fput "whisper #{my_partner} All done!"
    auto_run.call
  elsif result =~ /is already prone/i
    waitrt?
    fput "pull #{my_partner}"
    sweep_partner_start.call
  elsif result =~ /You might want to stand up first./i
    stand_up.call
    sweep_partner_start.call
  elsif result =~ /repetition|Roundtime/i
    sweep_partner_start.call
  elsif result =~ /Sweep what\?/i
    exit
  elsif result.nil?
    sweep_partner_start.call
  end
}

sweep_defend = proc{
  fput "gld"
  waitfor "The Training Administrator told you to defend against a partner"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      stand_up.call if !standing?
      waitrt?
      multifput "gld stance def", "stance off"
      partner_room.call
      wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i } }
      fput "whisper #{my_partner} I need to be swept."
      sweep_defend_start.call
      break
    end
  end
}

sweep_defend_start = proc{
  while line = get
    if line =~ /You have (.*) repetition/i
      reps = $1
      fput "whisper #{my_partner} #{reps} more." if update_partner == "on"
    elsif line =~ /You have completed your training task/i
      fput "whisper #{my_partner} All done. Thank you!"
      auto_run.call
    end
  end
}

sweep_master = proc{
  fput "gld"
  waitfor "The Training Administrator told you to get some lessons from the footpads"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      waitrt?
      multifput "gld stance off", "stance off"
      move 'out' if checkpaths 'out'
      target_room = Room.current.find_nearest(training_master_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      GameObj.npcs.find { |npc| master = npc if npc.name =~ master_names }
      sweep_master_begin.call
      break
    end
  end
}

sweep_master_begin = proc{
  fput "ask #{master} about training sweep"
  waitfor "pulls you aside for some instruction."
  waitfor "says"
  sweep_master_start.call
}

sweep_master_start = proc{
  stand_up.call if !standing?
  stamina_check.call if checkstamina < 12
  waitrt?
  result = dothistimeout "sweep #{master}", 3, /You have completed your training task|is already prone|You might want to stand up first.|Roundtime/i
  if result =~ /You have completed your training task/i
    turnin.call
  elsif result =~ /is already prone/i
    waitrt?
    fput "hide" if !hidden?
    waitfor "stands back up"
    sweep_master_start.call
  elsif result =~ /You might want to stand up first./i
    stand_up.call
    sweep_master_start.call
  elsif result =~ /Roundtime/i
    waitrt?
    fput "hide" if !hidden?
    sweep_master_start.call
  elsif result.nil?
    sweep_master_start.call
  end
}

sweep_dummies = proc{
  fput "gld"
  waitfor "The Training Administrator told you to work out on the sweep dummies"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      waitrt?
      move 'out' if checkpaths 'out'
      target_room = Room.current.find_nearest(sweeping_dummies_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      fput "go dummies"
      sweep_dummy_start.call
      break
    end
  end
}

sweep_dummy_start = proc{
  stand_up.call if !standing?
  stamina_check.call if checkstamina < 12
  waitrt?
  result = dothistimeout "sweep dummy", 3, /You have completed your training task.|The dummy is swinging back and forth.|The dummy has fallen off its post, you'll need to FIX it.|repetition|fail to flip/i
  if result =~ /You have completed your training task./i
    turnin.call
  elsif result =~ /The dummy is swinging back and forth./i
    waitrt?
    fput "touch dummy"
    sweep_dummy_start.call
  elsif result =~ /The dummy has fallen off its post, you'll need to FIX it./i
    waitrt?
    fput "fix dummy"
    sweep_dummy_start.call
  elsif result =~ /repetition|fail to flip/i
    sweep_dummy_start.call
  elsif result.nil?
    sweep_dummy_start.call
  end
}

sweep_dirt = proc{
  fput "gld"
  waitfor "The Training Administrator told you to sweep the guild courtyard"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      number = 0
      target_room = Room.current.find_nearest(tool_rack_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      if Room.current.id == 17969
        dirt_rooms = icedirt_rooms
      elsif Room.current.id == 16581
        dirt_rooms = landingdirt_rooms
      elsif Room.current.id == 17941
        dirt_rooms = soldirt_rooms
      elsif Room.current.id == 17861
        dirt_rooms = illistim_dirt_rooms
      else
        echo "Error! Stuck in sweep_dirt, try running script again and please inform author of this error."
      end
      fput "put my broom on rack" if checkright =~ /broom/i || checkleft =~ /broom/i
      fput "put my bag on rack" if checkright =~ /bag/i || checkleft =~ /bag/i
      stow.call
      multifput "get broom from rack", "get bag from rack"
      sweep_dirt_move.call
      break
    end
  end
}

sweep_dirt_move = proc{
  if number > dirt_rooms.length - 1
    sweep_dirt_full.call
  else
    start_script "go2", [dirt_rooms.at(number)]
    wait_while{ running?('go2') }
    number += 1
    sweep_dirt_sweep.call
  end
}

sweep_dirt_sweep = proc{
  waitrt?
  result = dothistimeout "push broom", 3, /There is no dirt here to sweep|Get what|Round time/i
  if result =~ /There is no dirt here to sweep/i
    sweep_dirt_get.call
  elsif result =~ /Get what/i
    sweep_dirt_move.call
  elsif result =~ /Round time/i
    sweep_dirt_sweep.call
  elsif result.nil?
    sweep_dirt_sweep.call
  end
}

sweep_dirt_get = proc{
  waitrt?
  result = dothistimeout "get pile", 3, /Your bag is full\, time to go empty it out|You don't see a dirt pile that you have created here|You gather a dirt pile into your burlap bag.|Get what/i
  if result =~ /Your bag is full\, time to go empty it out|You don't see a dirt pile that you have created here/i
    sweep_dirt_full.call
  elsif result =~ /You gather a dirt pile into your burlap bag.|Get what/i
    sweep_dirt_move.call
  elsif result.nil?
    sweep_dirt_get.call
  end
}

sweep_dirt_full = proc{
  number = 0
  target_room = Room.current.find_nearest(tool_rack_room_number)
  start_script 'go2', [ target_room.to_s ]
  wait_while{ running?('go2') }
  waitrt?
  result = dothistimeout "put my bag in bin", 3, /You have completed|Your burlap bag isn't full yet.|repetition/i
  if result =~ /You have completed/i
    target_room = Room.current.find_nearest(tool_rack_room_number)
    start_script 'go2', [ target_room.to_s ]
    wait_while{ running?('go2') }
    multifput "put my broom on rack", "put my bag on rack"
    turnin.call
  elsif result =~ /Your burlap bag isn't full yet.|repetition/i
    sweep_dirt_move.call
  elsif result.nil?
    sweep_dirt_full.call
  end
}

sweep_critters = proc{
  fput "gld"
  waitfor "The Training Administrator told you to practice sweeping creatures"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      if do_critter_sweep_tasks == "yes"
        fput "gld stance off"
        echo "Go sweep some critters! Restart script when you have finished this task."
        exit
      elsif do_critter_sweep_tasks == "no"
        target_room = Room.current.find_nearest(training_administrator_room)
        start_script 'go2', [ target_room.to_s ]
        wait_while{ running?('go2') }
        GameObj.npcs.find { |npc| person = npc if npc.name =~ training_administrator_names }
        multifput "ask #{person} about trade sweep", "ask #{person} about train sweep"
        go_to_task.call
      elsif do_critter_sweep_tasks == "auto"
        stow.call
        multifput "gld stance o", "get my #{mainweapon}", "get my #{shield}"
        fput "remove my #{shield}" if checkleft == nil
        my_room = Room.current.id
        auto_critter_sweep_tasks.call
      end
      break
    end
  end
}

substart = proc{
  fput "gld"
  waitfor "Subdue skill"
  while line = get
    (garlic_start.call;break) if line =~ /The Training Administrator told you to crush up some/i
    (mannequins_start.call;break) if line =~ /The Training Administrator told you to ding up a few melons at the subdue mannequins./i
    (windows_get_rag.call;break) if line =~ /The Training Administrator told you to clean the windows in the guild./i
    (sub_critters.call;break) if line =~ /The Training Administrator told you to try and subdue some creatures/i
    (promotion.call;break) if line =~ /Congratulations\, you\'ve earned a rank|You need to get promoted to your next rank|You have earned enough training points for your next rank./i
    (turnin.call;break) if line =~ /You are not currently training in this skill/i
  end
}

sub_critters = proc{
  fput "gld stance off"
  echo "Go subdue some critters! Restart script when you have finished this task."
  exit
}

garlic_start = proc{
  fput "gld"
  waitfor "The Training Administrator told you to crush up some"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      stow.call
      fput "get my #{weapon}"
      target_room = Room.current.find_nearest(kitchen_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      move 'go kitchen'
      get_garlic.call
      break
    end
  end
}

get_garlic = proc{
  stand_up.call if !standing?
  waitrt?
  fput "put clove on block"
  result = dothistimeout "subdue block", 3, /You have completed your training task|You\'re done with this task for now\, you should see the Training Administrator for what to do next|PUT BLOCK IN POT|Put it in the pot now|You\'ll need to have a clove of garlic on the block before trying to smash it properly|You\'re going to need to CLEAN the block before putting another clove on it|Roundtime/i
  if result =~ /You have completed your training task|You\'re done with this task for now\, you should see the Training Administrator for what to do next/i
    turnin.call
  elsif result =~ /PUT BLOCK IN POT|Put it in the pot now/i
    waitrt?
    fput "put block in pot"
    get_garlic.call
  elsif result =~ /You\'ll need to have a clove of garlic on the block before trying to smash it properly|You\'re going to need to CLEAN the block before putting another clove on it/i
    waitrt?
    fput "clean block"
    get_garlic.call
  elsif result =~ /Roundtime/i
    stand_up.call if !standing?
    stamina_check.call if checkstamina < 12
    waitrt?
    fput "subdue block"
    get_garlic.call
  elsif result.nil?
    get_garlic.call
  end
}

mannequins_start = proc{
  fput "gld"
  waitfor "The Training Administrator told you to ding up a few melons at the subdue mannequins"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      waitrt?
      stow.call
      fput "get my #{weapon}"
      target_room = Room.current.find_nearest(mannequin_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      move 'go mannequin'
      mannequins_subdue.call
      break
    end
  end
}

mannequins_subdue = proc{
  stand_up.call if !standing?
  stamina_check.call if checkstamina < 12
  waitrt?
  result = dothistimeout "subdue mann", 3, /You have completed your training task|clean|needs a head|Round time|repetition|Roundtime/i
  if result =~ /You have completed your training task/i
    turnin.call
  elsif result =~ /Round time|repetition|Roundtime/i
    mannequins_subdue.call
  elsif result =~ /clean/i
    waitrt?
    fput "clean mann"
    mannequins_subdue.call
  elsif result =~ /needs a head/i
    waitrt?
    multifput "clean mann", "put melon on mann"
    mannequins_subdue.call
  elsif result.nil?
    mannequins_subdue.call
  end
}

windows_get_rag = proc{
  fput "gld"
  waitfor "The Training Administrator told you to clean the windows in the guild", "The Training Administrator told you to clean the guild windows."
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      number = 0
      target_room = Room.current.find_nearest(tool_rack_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      my_room = Room.current.id
      if Room.current.id == 17969
        current_window_rooms = icewindow_rooms
      elsif Room.current.id == 16581
        current_window_rooms = landingwindow_rooms
      elsif Room.current.id == 17941
        current_window_rooms = solwindow_rooms
      elsif Room.current.id == 17861
        current_window_rooms = illistimwindow_rooms
      else
        echo "Error! Stuck in windows_get_rag, try running script again and please inform author of this error."
      end
      fput "put my rag on rack" if checkright =~ /rag/i or checkleft =~ /rag/i
      stow.call
      fput "get rag from rack"
      windows_move.call
      break
    end
  end
}

windows_clean = proc{
  result = dothistimeout "rub window", 3, /You have completed this task|repetition|let someone else have a crack at it/i
  if result =~ /You have completed this task/i
    waitrt?
    target_room = Room.current.find_nearest(tool_rack_room_number)
    start_script 'go2', [ target_room.to_s ]
    wait_while{ running?('go2') }
    multifput "put my rag on rack", "get my #{mainweapon}", "get my #{shield}"
    fput "remove my #{shield}" if checkleft == nil
    fput "stance def"
    start_script 'go2', [my_room]
    wait_while{ running?('go2') }
    turnin.call
  elsif result =~ /repetition|let someone else have a crack at it/i
    windows_move.call
  elsif result.nil?
    windows_clean.call
  end
}

windows_move = proc{
  if number > current_window_rooms.length - 1
    if do_other_guild_tasks == "yes"
      target_room = Room.current.find_nearest(tool_rack_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      multifput "put my rag on rack", "get my #{mainweapon}", "get my #{shield}"
      fput "remove my #{shield}" if checkleft == nil
      fput "stance def"
      if Room.current.id == 17969
        go_to_room = 16581
      elsif Room.current.id == 16581
        go_to_room = 17941
      elsif Room.current.id == 17941
        go_to_room = 17969
      end
      start_script "go2", [go_to_room]
      wait_while{ running?('go2') }
      number = 0
      target_room = Room.current.find_nearest(tool_rack_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      if Room.current.id == 17969
        current_window_rooms = icewindow_rooms
      elsif Room.current.id == 16581
        current_window_rooms = landingwindow_rooms
      elsif Room.current.id == 17941
        current_window_rooms = solwindow_rooms
      elsif Room.current.id == 17861
        current_window_rooms = illistimwindow_rooms
      else
        echo "Error! Stuck in sweep_dirt, try running script again and please inform author of this error."
      end
      fput "put my rag on rack" if checkright =~ /rag/i or checkleft =~ /rag/i
      stow.call
      fput "get rag from rack"
      windows_move.call
    else
      waitrt?
      target_room = Room.current.find_nearest(tool_rack_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      multifput "put my rag on rack", "get my #{mainweapon}", "get my #{shield}"
      fput "remove my #{shield}" if checkleft == nil
      fput "stance def"
      start_script 'go2', [my_room]
      wait_while{ running?('go2') }
      respond "Couldn't finish task, try starting script again in 20 minutes."
      exit
    end
  else
    start_script "go2", [current_window_rooms.at(number)]
    wait_while{ running?('go2') }
    number += 1
    windows_clean.call
  end
}

lmasstart = proc{
  fput "gld"
  waitfor "Lock Mastery skill"
  while line = get
    (lmas_tough_boxes.call;break) if line =~ /pick some tough boxes from creatures/i
    (lmas_trick.call;break) if line =~ /challenging boxes to practice your latest trick for an audience/i
    (keys.call;break) if line =~ /cut keys for some locks you make/i
    (lmas_footpad_talk.call;break) if line =~ /The Training Administrator told you to visit a master footpad for a talk/i
    (lmas_footpad_challenge.call;break) if line =~ /The Training Administrator told you to pit your skills against a footpad./i
    (customize.call;break) if line =~ /customize some lockpicks and keys/i
    (promotion.call;break) if line =~ /(Congratulations\, you\'ve earned a rank|You need to get promoted to your next rank|You have earned enough training points for your next rank.)/i
    (turnin.call;break) if line =~ /You are not currently training in this skill/i
  end
}

lmas_footpad_talk = proc{
  fput "gld"
  waitfor "The Training Administrator told you to visit a master footpad for a talk"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      target_room = Room.current.find_nearest(training_master_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      GameObj.npcs.find { |npc| master = npc if npc.name =~ master_names }
      talk_to_footpad_masters.call
      break
    end
  end
}

talk_to_footpad_masters = proc{
  fput "ask #{master} about train lmas"
  while line = get
    (lmas_footpad_lock_start.call;break) if line =~ /LMASTER RELOCK the box on the table/i
    (lmas_lockpick_start.call;break) if line =~ /just because you can make your own lockpicks/i
    (customize_footpad_pre.call;break) if line =~ /yer coming down the homestretch now/i
  end
}

lmas_tough_boxes = proc{
  fput "gld"
  waitfor "pick some tough boxes from creatures"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    (echo "Pick some tough boxes then restart script when finished with task.";exit) if line =~ /remaining to complete this task|remaining for this task/i
  end
}

lmas_trick = proc{
  fput "gld"
  waitfor "challenging boxes to practice your latest trick for an audience"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    (echo "Practice your latest trick for an audience then restart script when finished with task.";exit) if line =~ /remaining to complete this task|remaining for this task/i
  end
}

customize = proc{
  fput "gld"
  waitfor "customize some lockpicks and keys"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      fput "gld"
      waitfor "Lock Mastery skill"
      numberoflockpicks = matchfindword "You have ?"
      numberoflockpicks = Integer(numberoflockpicks)
      start_script 'go2', [ 'bank', '--disable-confirm' ]
      wait_while{ running?('go2') }
      multifput "depo all", "withdraw 5000 silvers"
      target_room = Room.current.find_nearest(toolbenches_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      fput "go tool"
      customize_create.call
    end
  end
}

customize_create = proc{
  if numberoflockpicks > 0
    waitrt?
    multifput "order 26", "buy"
    result = dothistimeout "lmas create", 3, /You carefully slice the ruined part of|As you remove the resulting/i
    if result =~ /You carefully slice the ruined part of/i
      waitrt?
      fput "drop copper"
      customize_create.call
    elsif result =~ /As you remove the resulting/i
      waitrt?
      fput "swap"
      multifput "lmas customize edge brass", "lmas customize edge brass"
      waitrt?
      numberoflockpicks -= 1
      fput "drop my lockpick"
      customize_create.call
    end
  else
    turnin.call
  end
}

customize_footpad_pre = proc{
  move 'out' if checkpaths 'out'
  fput "gld"
  waitfor "Lock Mastery skill"
  numberoflockpicks = matchfindword "You have ?"
  numberoflockpicks = Integer(numberoflockpicks)
  start_script 'go2', [ 'bank', '--disable-confirm' ]
  wait_while{ running?('go2') }
  multifput "depo all", "withdraw 5000 silvers"
  target_room = Room.current.find_nearest(toolbenches_room_number)
  start_script 'go2', [ target_room.to_s ]
  wait_while{ running?('go2') }
  fput "go tool"
  customize_footpad_create.call
}

customize_footpad_create = proc{
  if numberoflockpicks > 0
    waitrt?
    multifput "order 26", "buy"
    result = dothistimeout "lmas create", 3, /You carefully slice the ruined part of|As you remove the resulting/i
    if result =~ /You carefully slice the ruined part of/i
      waitrt?
      fput "drop copper"
      customize_footpad_create.call
    elsif result =~ /As you remove the resulting/i
      waitrt?
      fput "swap"
      multifput "lmas customize edge brass", "lmas customize edge brass"
      waitrt?
      numberoflockpicks -= 1
      fput "stow my lockpick"
      customize_footpad_create.call
    end
  else
    move 'out' if checkpaths 'out'
    target_room = Room.current.find_nearest(training_master_room_number)
    start_script 'go2', [ target_room.to_s ]
    wait_while{ running?('go2') }
    GameObj.npcs.find { |npc| master = npc if npc.name =~ master_names }
    fput "ask #{master} about training lmas"
    waitfor "I assume you've got some lockpicks or keys to show me"
    customize_footpad_hand_in1.call
  end
}

customize_footpad_hand_in1 = proc{
  result = dothistimeout "get copper lockpick from my #{stow_container}", 3, /Get what|You remove/i
  if result =~ /Get what/i
    turnin.call
  elsif result =~ /You remove/i
    multifput "give my lockpick to #{master}", "drop my lockpick"
    customize_footpad_hand_in1.call
  end
}

lmas_footpad_lock_start = proc{
  waitrt?
  fput "get my #{lmas_lockpick}" if checkright !~ /#{lmas_lockpick}/
  multifput "get box", "lmas relock my box"
  result = dothistimeout "give my box to #{master}", 3, /You have completed your training task|repetition|roundtime/i
  if result =~ /You have completed your training task/i
    waitrt?
    fput "put my #{lmas_lockpick} in my #{lockpick_container}"
    turnin.call
  elsif result =~ /repetition|roundtime/i
    lmas_footpad_lock_start.call
  elsif result.nil?
    lmas_footpad_lock_start.call
  end
}

lmas_footpad_challenge = proc{
  fput "gld"
  waitfor "pit your skills against a footpad"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      stow.call
      move 'out' if checkpaths 'out'
      target_room = Room.current.find_nearest(training_master_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      lmas_footpad_challenge1.call
      break
    end
  end
}

lmas_footpad_challenge1 = proc{
  move 'out' if checkpaths 'out'
  GameObj.npcs.find { |npc| master = npc if npc.name =~ master_names }
  number = 0
  fput "ask #{master} about training lmas"
  while line = get
    (turnin.call;break) if line =~/gives you a strange look/i
    (fput "nod";lmas_footpad_challenge_begin.call;break) if line =~ /just nod to me when yer feelin/i
  end
}


lmas_footpad_challenge_begin = proc{
  fput "put my lockpick on table" if checkright == "lockpick"
  number = number + 1
  if number <= 5
    lmas_footpad_challenge_begin1.call
  else
    lmas_footpad_challenge_wait.call
  end
}

lmas_footpad_challenge_begin1 = proc{
  waitrt?
  result = dothistimeout "disarm #{box[number]}", 3, /You can see what appears to be a tiny hole next to the lock plate which doesn't seem to belong there|You discover no traps./i
  if result =~ /You can see what appears to be a tiny hole next to the lock plate which doesn't seem to belong there/i
    lmas_footpad_challenge_trap.call
  elsif result =~ /You discover no traps./i
    lmas_footpad_challenge_pick.call
  elsif result.nil?
    lmas_footpad_challenge_begin1.call
  end
}

lmas_footpad_challenge_trap = proc{
  waitrt?
  result = dothistimeout "disarm #{box[number]}", 3, /you nudge the end of the flag to one side|You can't seem to get the trap disarmed without setting it off by accident!/i
  if result =~ /you nudge the end of the flag to one side/i
    lmas_footpad_challenge_pick.call
  elsif result =~ /You can't seem to get the trap disarmed without setting it off by accident!/i
    lmas_footpad_challenge_trap.call
  elsif result.nil?
    lmas_footpad_challenge_trap.call
  end
}

lmas_footpad_challenge_pick = proc{
  waitrt?
  fput "get vaalin lockpick from table"
  result = dothistimeout "pick #{box[number]}", 3, /It opens|You are not able to pick the lock|Roundtime/i
  if result =~ /It opens/i
    lmas_footpad_challenge_begin.call
  elsif result =~ /You are not able to pick the lock|Roundtime/i
    lmas_footpad_challenge_pick.call
  elsif result.nil?
    lmas_footpad_challenge_pick.call.call
  end
}

lmas_footpad_challenge_wait = proc{
  while line = get
    (lmas_footpad_challenge1.call;break) if line =~ /escorts you back to the training area|Game\'s over/i
  end
}

cal = proc{
  stow.call
  target_room = Room.current.find_nearest(toolbenches_room_number)
  start_script 'go2', [ target_room.to_s ]
  wait_while{ running?('go2') }
  fput "go toolbench"
  waitfor "workshop instructions"
  fput "get my calipers"
  cal_start.call
}

cal_start = proc{
  waitrt?
  result = dothistimeout "lmaster cal my cal", 3, /Those calipers could not be more perfectly calibrated.|They practically glow with calibration!|need further tuning|Roundtime/i
  if result =~ /Those calipers could not be more perfectly calibrated.|They practically glow with calibration!/i
    fput "put my calipers in my #{calipers_container}"
    move 'out' if checkpaths 'out'
    exit
  elsif result =~ /need further tuning|Roundtime/i
    cal_start.call
  elsif result.nil?
    cal_start.call
  end
}

carve_go = proc{
  number_of_wedges = (script.vars[2].to_i)
  silvers_needed = number_of_wedges * 300
  if number_of_wedges == 1
    echo "Making 1 wedge"
  else
    echo "Making #{number_of_wedges} wedges."
  end
  stow.call
  start_script 'go2', [ 'bank', '--disable-confirm' ]
  wait_while{ running?('go2') }
  multifput "depo all", "withdraw #{silvers_needed} silvers"
  target_room = Room.current.find_nearest(toolbenches_room_number)
  start_script 'go2', [ target_room.to_s ]
  wait_while{ running?('go2') }
  fput "go toolbench"
  waitfor "workshop instructions"
  buy_block.call
}

buy_block = proc{
  fput "put my wedge in my #{wedge_container}" if checkleft == "wedge" or checkright == "wedge"
  fput "stow right" if checkright
  fput "stow left" if checkleft
  number_of_wedges -= 1
  if number_of_wedges <= 0
    echo "Done making wedges"
    move 'out' if checkpaths 'out'
    exit
  end
  waitrt?
  multifput "order 1", "buy"
  carve_start.call
}

carve_start = proc{
  waitrt?
  result = dothistimeout "carve my block", 3, /wedge|wooden block|You can\'t carve that\!/i
  if result =~ /wedge/i
    carve.call
  elsif result =~ /wooden block/i
    carve_start.call
  elsif result =~ /You can\'t carve that\!/
    echo "Done making wedges"
    move 'out' if checkpaths 'out'
    exit
  elsif result.nil?
    carve_start.call
  end
}

carve = proc{
  waitrt?
  result = dothistimeout "carve my wedge", 3, /You should RUB the wedge now.|Roundtime/i
  if result =~ /You should RUB the wedge now./i
    carve_rub.call
  elsif result =~ /Roundtime/i
    carve.call
  elsif result.nil?
    carve.call
  end
}

carve_rub = proc{
  waitrt?
  result = dothistimeout "rub my wedge", 3, /is ready for use!|Roundtime/i
  if result =~ /is ready for use!/i
    buy_block.call
  elsif result =~ /Roundtime/i
    carve_rub.call
  elsif result.nil?
    carve_rub.call
  end
}

lmas_lockpick_start = proc{
  move 'out' if checkpaths 'out'
  fput "gld"
  waitfor "Lock Mastery skill"
  numberoflockpicks = matchfindword "You have ?"
  numberoflockpicks = Integer(numberoflockpicks)
  echo "Making #{numberoflockpicks} lockpicks"
  start_script 'go2', [ 'bank', '--disable-confirm' ]
  wait_while{ running?('go2') }
  multifput "depo all", "withdraw 5000 silvers"
  target_room = Room.current.find_nearest(toolbenches_room_number)
  start_script 'go2', [ target_room.to_s ]
  wait_while{ running?('go2') }
  fput "go tool"
  lock_pick_create.call
}

lock_pick_create = proc{
  if numberoflockpicks > 0
    waitrt?
    multifput "order 26", "buy"
    result = dothistimeout "lmas create", 3, /You carefully slice the ruined part of|As you remove the resulting/i
    if result =~ /You carefully slice the ruined part of/i
      waitrt?
      fput "drop copper"
      lock_pick_create.call
    elsif result =~ /As you remove the resulting/i
      numberoflockpicks -= 1
      waitrt?
      fput "stow my lockpick"
      lock_pick_create.call
    end
  else
    move 'out' if checkpaths 'out'
    target_room = Room.current.find_nearest(training_master_room_number)
    start_script 'go2', [ target_room.to_s ]
    wait_while{ running?('go2') }
    GameObj.npcs.find { |npc| master = npc if npc.name =~ master_names }
    lockpick_handin.call
    fput "ask #{master} about train lmas"
    waitfor "got some lockpicks to show me"
    lockpick_handin1.call
  end
}

lockpick_handin1 = proc{
  result = dothistimeout "get copper lockpick from my #{stow_container}", 3, /Get what|You remove/i
  if result =~ /Get what/i
    move 'out' if checkpaths 'out'
    target_room = Room.current.find_nearest(training_administrator_room)
    start_script 'go2', [ target_room.to_s ]
    wait_while{ running?('go2') }
    GameObj.npcs.find { |npc| person = npc if npc.name =~ training_administrator_names }
    multifput "ask #{training_administrator_names} about train lock", "ask #{training_administrator_names} about train lock"
    lmasstart.call
  elsif result =~ /You remove/i
    multifput "give my lockpick to #{master}", "drop my lockpick"
    lockpick_handin1.call
  end
}

gamstart = proc{
  waitrt?
  fput "put my #$stealth_get_item in my #$stealth_get_item_container" if checkleft == "#$stealth_get_item"
  fput "put my #$stealth_get_item in my #$stealth_get_item_container" if checkright == "#$stealth_get_item"
  stow.call
  fput "gld"
  waitfor "Rogue Gambits skill"
  while line = get
    (gam_learn_start.call;break) if line =~ /partner to teach you your latest trick/i
    (gam_audience_start.call;break) if line =~ /The Training Administrator told you to practice your latest trick in front of an audience/i
    (gam_speed_start.call;break) if line =~ /one minute/i
    (gam_teach_start.call;break) if line =~ /teach a fellow guildmember something about rogue gambits/i
    (promotion.call;break) if line =~ /(Congratulations, you've earned a rank|You need to get promoted to your next rank|You have earned enough training points for your next rank.)/i
    (turnin.call;break) if line =~ /You are not currently training in this skill/i
  end
}

gam_learn_start = proc{
  fput "gld"
  waitfor "partner to teach you your latest trick"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      exit if script.vars[2] == nil
      hide_before_trick = "yes" if gam =~ /stealth/i
      get_item_trick = "yes" if gam =~ /get/i
      partner_room.call
      wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i } }
      multifput "get my #$stealth_get_item from my #$stealth_get_item_container", "drop my #$stealth_get_item" if get_item_trick == "yes"
      fput "whisper #{my_partner} rgam teach #{checkname} #{gam}"
      until !hiding?
        waitrt?
        fput "unhide"
      end
      if gam =~ /stealth/i
        if gam =~ /stand/i
          until kneeling?
            waitrt?
            fput "kneel"
          end
        else
          until standing?
            waitrt?
            fput "stand"
          end
          waitrt?
        end
      end
      fput "whisper #{my_partner} I am ready to learn"
      gam_learn_start1.call
      break
    end
  end
}

gam_learn_start1 = proc{
  waitrt?
  until !hiding?
    waitrt?
    fput "unhide"
  end
  if gam =~ /stealth/i
    if gam =~ /stand/i
      until kneeling?
        waitrt?
        fput "kneel"
      end
    else
      until standing?
        waitrt?
        fput "stand"
      end
    end
  end
  waitrt?
  if get_item_trick == "yes"
    waitfor "shows you how to take an item from the ground without giving yourself away"
  elsif hide_before_trick == "yes"
    waitfor "gives you some pointers"
  end
  gam_learn_start2.call
}

gam_learn_start2 = proc{
  waitrt?
  until !hiding?
    waitrt?
    fput "unhide"
  end
  if gam =~ /stealth/i
    if gam =~ /stand/i
      until kneeling?
        waitrt?
        fput "kneel"
      end
    else
      until standing?
        waitrt?
        fput "stand"
      end
      waitrt?
    end
  end
  fput "drop my #$stealth_get_item" if get_item_trick == "yes"
  if hide_before_trick == "yes"
    until hiding?
      waitrt?
      fput "hide"
    end
  end
  waitrt?
  result = dothistimeout "rgam #{gam}", 2, /You need to be holding something first|You already have that|You have completed your training task|You have (.*) repetition|but realize that doing so would reveal your location|suddenly become aware that your actions have revealed your location|Just how stealthy are you trying to be|but have revealed yourself from hiding in doing so|but realize that doing so would compromise your hidden position/i
  if result =~ /You need to be holding something first/i
    fput "get my #{weapon}"
    gam_learn_start2.call
  elsif result =~ /You already have that/i
    fput "stow #{weapon}"
    gam_learn_start1.call
  elsif result =~ /You have completed your training task/i
    fput "whisper #{my_partner} All done. Thank you!"
    until !hiding?
      waitrt?
      fput "unhide"
    end
    hide_before_trick = nil
    get_item_trick = nil
    fput "put my #$stealth_get_item in my #$stealth_get_item_container" if get_item_trick == "yes"
    auto_run.call
  elsif result =~ /Just how stealthy are you trying to be/i
    until !hiding?
      waitrt?
      fput "unhide"
    end
    gam_learn_start2.call
  elsif result =~ /suddenly become aware that your actions have revealed your location|but realize that doing so would reveal your location/i
    gam_learn_start2.call
  elsif result =~ /You have (.*) repetition/i
    reps = $1
    fput "whisper #{my_partner} #{reps} more." if update_partner == "on"
    until !hiding?
      waitrt?
      fput "unhide"
    end
    gam_learn_start1.call
  elsif result =~ /but have revealed yourself from hiding in doing so/i
    gam_learn_start2.call
  elsif result =~ /but realize that doing so would compromise your hidden position/i
    gam_learn_start2.call
  elsif result.nil?
    until !hiding?
      waitrt?
      fput "unhide"
    end
    gam_learn_start2.call
  end
}

gam_audience_start = proc{
  fput "gld"
  waitfor "The Training Administrator told you to practice your latest trick in front of an audience"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      target_room = Room.current.find_nearest(audience_rooms)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      hide_before_trick = "yes" if gam =~ /stealth/i
      get_item_trick = "yes" if gam =~ /get/i
      multifput "get my #$stealth_get_item from my #$stealth_get_item_container", "drop my #$stealth_get_item" if get_item_trick == "yes"
      gam_audience_start1.call
      break
    end
  end
}

gam_audience_start1 = proc{
  waitrt?
  until !hiding?
    waitrt?
    fput "unhide"
  end
  if gam =~ /stealth/i
    if gam =~ /stand/i
      until kneeling?
        waitrt?
        fput "kneel"
      end
    else
      until standing?
        waitrt?
        fput "stand"
      end
    waitrt?
    end
  end
  fput "drop my #$stealth_get_item" if get_item_trick == "yes"
  if hide_before_trick == "yes"
    until hiding?
      waitrt?
      fput "hide"
    end
  end
  i = 0
  checkpcs.each { |pc| i += 1; break if pc == Char.name }
  echo "#{i} people are here."
  waitrt?
  result = dothistimeout "rgam #{gam}", 5, /You need to be holding something first|You already have that|You have completed your training task|repetition|but realize that doing so would reveal your location|suddenly become aware that your actions have revealed your location|Just how stealthy are you trying to be|but have revealed yourself from hiding in doing so/i
  if result =~ /You need to be holding something first/i
      fput "get my #{weapon}"
      gam_audience_start1.call
  elsif result =~ /You already have that/i
      fput "stow #{weapon}"
      gam_audience_start1.call
  elsif result =~ /You have completed your training task/i
    if get_item_trick == "yes"
      fput "put my #$stealth_get_item in my #$stealth_get_item_container"
    end
    hide_before_trick = nil
    get_item_trick = nil
    turnin.call
  elsif result =~ /repetition/i
    until !hiding?
      waitrt?
      fput "unhide"
    end
    sleep 30
    gam_audience_start1.call
  elsif result =~ /suddenly become aware that your actions have revealed your location/i
    until !hiding?
      waitrt?
      fput "unhide"
    end
    gam_audience_start1.call
  elsif result =~ /but have revealed yourself from hiding in doing so|but realize that doing so would compromise your hidden position|Just how stealthy are you trying to be/i
    gam_audience_start1.call
  elsif result.nil?
    until !hiding?
      waitrt?
      fput "unhide"
    end
    sleep 3
    gam_audience_start1.call
  end
}

gam_speed_start = proc{
  fput "gld"
  waitfor "one minute"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    (gam_speed_begin.call;break) if line =~ /remaining to complete this task|remaining for this task/i
  end
}

gam_speed_begin = proc{
  hide_before_trick = "yes" if gam =~ /stealth/i
  get_item_trick = "yes" if gam =~ /get/i
  multifput "get my #$stealth_get_item from my #$stealth_get_item_container", "drop my #$stealth_get_item" if get_item_trick == "yes"
  waitrt?
  until !hiding?
    waitrt?
    fput "unhide"
  end
  if gam =~ /stealth/i
    if gam =~ /stand/i
      until kneeling?
        waitrt?
        fput "kneel"
      end
    else
      until standing?
        waitrt?
        fput "stand"
      end
    waitrt?
    end
  end
  fput "drop my #$stealth_get_item" if get_item_trick == "yes"
  if hide_before_trick == "yes"
    until hiding?
      waitrt?
      fput "hide"
    end
  end
  waitrt?
  result = dothistimeout "rgam #{gam}", 5, /You need to be holding something first|You already have that|You have completed your training task|(repetition|You must succeed)|but realize that doing so would reveal your location|suddenly become aware that your actions have revealed your location|Just how stealthy are you trying to be|but have revealed yourself from hiding in doing so|but realize that doing so would compromise your hidden position/i
  if result =~ /You need to be holding something first/i
    fput "get my #{weapon}"
    gam_speed_begin.call
  elsif result =~ /You already have that/i
    fput "stow #{weapon}"
    gam_speed_begin.call
  elsif result =~ /You have completed your training task/i
    fput "put my #$stealth_get_item in my #$stealth_get_item_container" if get_item_trick == "yes"
    hide_before_trick = nil
    get_item_trick = nil
    turnin.call
  elsif result =~ /repetition|You must succeed|but realize that doing so would reveal your location|Just how stealthy are you trying to be|but have revealed yourself from hiding in doing so/i
    gam_speed_begin.call
  elsif result =~ /suddenly become aware that your actions have revealed your location/i
    until !hiding?
      waitrt?
      fput "unhide"
    end
    gam_speed_begin.call
  elsif result.nil?
    until !hiding?
      waitrt?
      fput "unhide"
    end
    gam_speed_begin.call
  end
}

gam_teach_start = proc{
  fput "gld"
  waitfor "teach a fellow guildmember something about rogue gambits"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      exit if script.vars[2] == nil
      partner_room.call
      wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i } }
      fput "whisper #{my_partner} rgam #{gam}"
      waitfor "I am ready to learn"
      partner = GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i }
      gam_teach_start1.call
      break
    end
  end
}

gam_teach_start1 = proc{
  if reget 10, "You have completed your training task"
    wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i } }
    fput "whisper #{my_partner} All done. Thank you!"
    auto_run.call
  end
  waitrt?
  if gam =~ /stealth/i
    if gam =~ /stand/i
      wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{partner}/i and partner.status =~ /kneel/ } }
    else
      wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{partner}/i and partner.status.nil? } }
    end
  end
  waitrt?
  result = dothistimeout "rgam teach #{my_partner} #{gam}", 5, /You need to have free hands to teach this gambit|You already have that|You should have a silver coin on you to teach this gambit|Wait a few seconds and try again|You have completed your training task|You have (.*) repetition|You need to be holding something first|Who are you trying to teach/i
  if result =~ /You need to have free hands to teach this gambit/i
    stow.call
    gam_teach_start1.call
  elsif result =~ /You already have that/i
    fput "stow #{weapon}"
    gam_teach_start1.call
  elsif result =~ /You should have a silver coin on you to teach this gambit/i
    fput "whisper #{my_partner} Need a coin, be right back."
    currentroom = Room.current.id
    start_script 'go2', [ 'bank', '--disable-confirm' ]
    wait_while{ running?('go2') }
    fput "withdraw 2 silvers"
    start_script "go2", [ "#{currentroom}" ]
    wait_while{ running?('go2') }
    gam_teach_start1.call
  elsif result =~ /Wait a few seconds and try again/i
    sleep 2
    gam_teach_start1.call
  elsif result =~ /You have completed your training task/i
    wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{script.vars[3]}(.*)/i } }
    fput "whisper #{my_partner} All done. Thank you!"
    auto_run.call
  elsif result =~ /You have (.*) repetition/i
    reps = $1
    wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{script.vars[3]}(.*)/i } }
    fput "whisper #{my_partner} #{reps} more." if update_partner == "on"
    gam_teach_start1.call
  elsif result =~ /You need to be holding something first/
    fput "get my #{weapon}"
    gam_teach_start1.call
  elsif result =~ /Who are you trying to teach/
    sleep 2
    gam_teach_start1.call
  elsif result.nil?
    gam_teach_start1.call
  end
}

repair = proc{
  stow.call
  target_room = Room.current.find_nearest(toolbenches_room_number)
  start_script 'go2', [ target_room.to_s ]
  wait_while{ running?('go2') }
  fput "go toolbench"
  getpick.call
}

keys = proc{
  fput "gld"
  waitfor "cut keys for some locks you make"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      start_script 'go2', [ 'bank', '--disable-confirm' ]
      wait_while{ running?('go2') }
      multifput "depo all", "withdraw 5000 silvers"
      target_room = Room.current.find_nearest(toolbenches_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      fput "go tool"
      keys_1.call
      break
    end
  end
}

keys_1 = proc{
  waitrt?
  multifput "drop my key", "drop my assem"
  multifput "lmas lock create 25", "lmas lock create 25"
  waitrt?
  multifput "order 25", "buy"
  result = dothistimeout "lmas cut key", 5, /repetition|You have completed your training task/i
  if result =~ /repetition/i
    keys_1.call
  elsif result =~ /You have completed your training task/i
    waitrt?
    multifput "drop my key", "drop my assem", "out"
    turnin.call
  end
}

cheapstart = proc{
  fput "gld"
  waitfor "Cheap Shot skill"
  while line = get
    (footstomp_defend.call;break) if line =~ /The Training Administrator told you to practice defending against footstomps./i
    (footstomp_partner.call;break) if line =~ /The Training Administrator told you to practice footstomping a partner./i
    (cheap_critter.call;break) if line =~ /The Training Administrator told you to tweak some creatures\' noses.|The Training Administrator told you to practice templeshot on some creatures./i
    (cheap_plants.call;break) if line =~ /The Training Administrator told you to water the guild plants./i
    (sweep_dirt.call;break) if line =~ /The Training Administrator told you to sweep the guild courtyard./i
    (windows_get_rag.call;break) if line =~ /The Training Administrator told you to clean the guild windows./i
    (promotion.call;break) if line =~ /(Congratulations, you've earned a rank|You need to get promoted to your next rank|You have earned enough training points for your next rank.)/i
    (turnin.call;break) if line =~ /You are not currently training in this skill/i
  end
}

footstomp_defend = proc{
  fput "gld"
  waitfor "The Training Administrator told you to practice defending against footstomps."
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      exit if script.vars[2] == nil
      multifput "gld stance def", "stance off"
      partner_room.call
      wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i } }
      fput "whisper #{my_partner} I need to be footstomped."
      foot_stomp_defend1.call
      break
    end
  end
}

foot_stomp_defend1 = proc{
  while line = get
    if line =~ /You have (.*) repetition/i
      reps = $1
      fput "whisper #{my_partner} #{reps} more." if update_partner == "on"
    elsif line =~ /You have completed your training task/i
      fput "whisper #{my_partner} All done. Thank you!"
      auto_run.call
      break
    end
  end
}


footstomp_partner = proc{
  fput "gld"
  waitfor "The Training Administrator told you to practice footstomping a partner"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      multifput "gld stance off", "stance off"
      partner_room.call
      wait_until { GameObj.pcs.find { |pc| pc.name =~ /#{my_partner}(.*)/i } }
      fput "whisper #{my_partner} I need to footstomp you."
      waitfor "Ready to be footstomped"
      footstomp_partner_start.call
      break
    end
  end
}

footstomp_partner_start = proc{
  stand_up.call if !standing?
  stamina_check.call if checkstamina < 12
  waitrt?
  result = dothistimeout "cheap foot #{my_partner}", 2, /just fell for a footstomp not long ago|You have completed your training task|You have (.*) repetition/i
  if result =~ /just fell for a footstomp not long ago/
    sleep 2
    footstomp_partner_start.call
  elsif result =~ /You have (.*) repetition/
    reps = $1
    fput "whisper #{my_partner} #{reps} more." if update_partner == "on"
    sleep 13
    footstomp_partner_start.call
  elsif result =~ /You have completed your training task/
    fput "whisper #{my_partner} All done!"
    waitrt?
    auto_run.call
  elsif result.nil?
    sleep 2
    footstomp_partner_start.call
  end
}


cheap_critter = proc{
  fput "gld"
  waitfor "The Training Administrator told you to tweak some creatures' noses.", "The Training Administrator told you to practice templeshot on some creatures."
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      fput "gld stance off"
      echo "Go cheap shot some critters!"
      exit
    end
  end
}

cheap_plants = proc{
  fput "gld"
  waitfor "The Training Administrator told you to water the guild plants"
  while line = get
    (turnin.call;break) if line =~ /You have completed|You have no repetitions remaining for this task/i
    if line =~ /remaining to complete this task|remaining for this task/i
      number = 0
      target_room = Room.current.find_nearest(tool_rack_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      my_room = Room.current.id
      if Room.current.id == 17969
        current_plant_rooms = iceplant_rooms
      elsif Room.current.id == 16581
        current_plant_rooms = landingplant_rooms
      elsif Room.current.id == 17941
        current_plant_rooms = solplant_rooms
      elsif Room.current.id == 17861
        current_plant_rooms = illistimplant_rooms
      else
        echo "Error! Stuck in sweep_dirt, try running script again and please inform author of this error."
      end
      fput "put my can in rack" if checkright =~ /can/i or checkleft =~ /can/i
      stow.call
      fput "get can"
      cheap_plants_move.call
    end
  end
}

cheap_plants_move = proc{
  if number > current_plant_rooms.length - 1
    if do_other_guild_tasks == "yes"
      target_room = Room.current.find_nearest(tool_rack_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      multifput "put my can in rack", "get my #{mainweapon}", "get my #{shield}"
      fput "remove my #{shield}" if checkleft == nil
      fput "stance def"
      if Room.current.id == 17969
        go_to_room = 16581
      elsif Room.current.id == 16581
        go_to_room = 17941
      elsif Room.current.id == 17941
        go_to_room = 17969
      end
      start_script "go2", [go_to_room]
      wait_while{ running?('go2') }
      number = 0
      target_room = Room.current.find_nearest(tool_rack_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      if Room.current.id == 17969
        current_plant_rooms = iceplant_rooms
      elsif Room.current.id == 16581
        current_plant_rooms = landingplant_rooms
      elsif Room.current.id == 17941
        current_plant_rooms = solplant_rooms
      elsif Room.current.id == 17861
        current_plant_rooms = illistimplant_rooms
      else
        echo "Error! Stuck in cheap_plants_move, try running script again and please inform author of this error."
      end
      fput "put my can in rack" if checkright =~ /can/i or checkleft =~ /can/i
      stow.call
      fput "get can"
      cheap_plants_move.call
    else
      waitrt?
      target_room = Room.current.find_nearest(tool_rack_room_number)
      start_script 'go2', [ target_room.to_s ]
      wait_while{ running?('go2') }
      multifput "put my can in rack", "get my #{mainweapon}", "get my #{shield}"
      fput "remove my #{shield}" if checkleft == nil
      fput "stance def"
      start_script 'go2', [my_room]
      wait_while{ running?('go2') }
      respond "Couldn't finish task, try starting script again in 20 minutes."
      exit
    end
  else
    start_script "go2", [current_plant_rooms.at(number)]
    wait_while{ running?('go2') }
    number += 1
    cheap_plants_water.call
  end
}

cheap_plants_water = proc{
  waitrt?
  fput "kneel"
  GameObj.loot.find { |loot| flower = loot.name if loot.name =~ flower_names }
  if Room.current.id == 17871 or Room.current.id == 17851 or Room.current.id == 17855 or Room.current.id == 17869 or Room.current.id == 17870
    flower = "wildflower"
  end
  if flower =~ /rose/
    flower = "rose"
  end
  result = dothistimeout "water #{flower}", 2, /You have completed|let someone else have a crack at it|repetition/i
  if result =~ /You have completed/i
    target_room = Room.current.find_nearest(tool_rack_room_number)
    start_script 'go2', [ target_room.to_s ]
    wait_while{ running?('go2') }
    multifput "put my can in rack", "get my #{mainweapon}", "get my #{shield}"
    fput "remove my #{shield}" if checkleft == nil
    fput "stance def"
    start_script 'go2', [my_room]
    wait_while{ running?('go2') }
    turnin.call
  elsif result =~ /let someone else have a crack at it|repetition/i
    cheap_plants_move.call
  end
}

if Char.prof != "Rogue"
  echo  "This script only works for rogues."
  exit
end
stow.call
my_partner = script.vars[2] if script.vars[2] != nil
(setup.call;exit) if script.vars[1] == "setup"
if (CharSettings['setup_has_been_run'] == nil || UserVars.rogue.nil?) and (script.vars[1] != 'setup')
  echo "Setup is required, type ;rogue setup and fill in all settings."
  exit
end
if script.vars[1] == nil
  respond "Type ;rogue sweep to automate solo sweep tasks. ;rogue sweep <partnername> for partner tasks."
  respond "Type ;rogue gam to automate solo gambit tasks. ;rogue gam <partnername> for partner tasks."
  respond "Type ;rogue cheap to automate solo cheap shot tasks. ;rogue cheap <partnername> for partner tasks."
  respond "Type ;rogue sub to automate solo subdue tasks."
  respond "Type ;rogue lmas do lockmastery tasks. Doesn't do all lockmastery tasks."
  respond "Typing ;rogue <sweep, gam, sub or lmas> will also turn in completed tasks to the NPC."
  respond "Type ;rogue cal to calibrate your calipers."
  respond "Type ;rogue wedge <number> to create specified number of wedges."
  respond "Note, do not type gld while script is running, it could make the script stop working."
  respond "Version: #{version}"
  exit
elsif script.vars[2] == "help"
  multifput "gld stance off", "stance off"
  if script.vars[1] == "sweep"
    help_sweep_partner_start.call
  elsif script.vars[1] == "cheap"
    help_cheap_partner_start.call
  end
elsif script.vars[2] == "teach"
  gam_teach_help_start.call
elsif script.vars[2] == "learn"
  gam_learn_help_start.call
elsif script.vars[1] == "def"
  (multifput "gld stance def", "stance off";exit)
elsif script.vars[1] == "cal"
  cal.call
elsif script.vars[1] == "wedge"
  carve_go.call
elsif script.vars[1] == "carve"
  carve_go.call
elsif script.vars[1] == "repair"
  repair.call
elsif script.vars[1] == "checkin"
  checkin.call
else
  go_to_task.call
end

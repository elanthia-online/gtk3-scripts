=begin

	This script will disarm, measure, pick (and will use the appropriate lockpick based on your skill and lock difficulty) and empty your boxes into your container. This script can also be used to automatically accept, disarm, 			measure, pick and hand back other people's boxes.
	
	Script will attempt to read lock difficulty for Rogues using calipers and for Bards using loresinging. If you are a Rogue or Bard and would prefer to skip all that and always use a vaalin lock pick instead then use the v variables listed below.

	Script will attempt to use vials bundled into your locksmith's pouch first for plated boxes, if no vials are bundled into your locksmith's pouch it will attempt to use wedges found in your wedge sack.

	Usage:
	;tpick <setup> must be done first before you can use this script. Be sure to fill out all of the settings.

	Use the following command line variables for how you want the script to run:

	other - will accept boxes handed to you, pick them, then hand them back to the person who handed you the box.
	ground - will pick all boxes on the ground but will not take loot out of them. Useful if you're picking boxes on the ground for someone else.
	worker - will get boxes from the worker and pick them.
	Not using "other", "ground", or "worker" will pick all boxes inside of your open containers and inside your disk.

	v - will skip measuring locks and always use a vaalin lockpick + 403 to pick all boxes.
	c - skips measuring and always starts with the lockpick in your copper lockpick setting then moves up list of lockpicks when needed.
	loot - to pick all boxes on the ground and take the loot out of each box.
	wedge - to always use a wedge to open boxes. In the case of scale traps the script will still attempt to pick the box first with a lockpick.
	bash - to bash open boxes
	relock - will relock the box after it has been opened and looted. Only works if you're picking your own boxes or you use both the ground and loot command line variables.
	pop - this will attempt to open boxes using 407 and 408 only. Does not work with the "other" variable but does work with "ground" picking. This option requires the knowledge of Piercing Gaze (416).
	disarm - this will ONLY check for and disarm traps, it will not open the boxes. Useful if you want to disarm traps for a warrior to bash them for guild reps. This feature only works with the ground variable.
	plin(ite) - will open all plinites in your open containers.

	The above commands can be used in any combination. Some examples:
	
	;tpick other v - will pick other people's boxes and always use a vaalin lockpick.
	;tpick loot ground v - will pick all boxes on the ground, will loot each box after picking them, and will always use a vaalin lockpick.
	;tpick - will pick all boxes in your open containers.


	The following commands cannot be used with the above commands:

	buy - script will fill up your locksmith's container with cotton balls and putty by buying them at the locksmith's shop. Script will exit once done.
	repair - script will repair any lockpicks that need repairing. Must be a rogue with the lmas skill to repair lockpicks.
	Currently repair only works in Icemule, Landing, Sol Haven and Illistim.


	Non Rogues and bards do not need to use the "v" command line, they will always pick boxes with a vaalin lockpick and won't use calipers.
	
	Author: Tgo01
	Version: 217

=end

CharSettings['scarab'] = 0 unless CharSettings['scarab']
CharSettings['needle'] = 0 unless CharSettings['needle']
CharSettings['jaws'] = 0 unless CharSettings['jaws']
CharSettings['sphere'] = 0 unless CharSettings['sphere']
CharSettings['crystal'] = 0 unless CharSettings['crystal']
CharSettings['scales'] = 0 unless CharSettings['scales']
CharSettings['sulphur'] = 0 unless CharSettings['sulphur']
CharSettings['cloud'] = 0 unless CharSettings['cloud']
CharSettings['acid_vial'] = 0 unless CharSettings['acid_vial']
CharSettings['springs'] = 0 unless CharSettings['springs']
CharSettings['fire_vial'] = 0 unless CharSettings['fire_vial']
CharSettings['spores'] = 0 unless CharSettings['spores']
CharSettings['plate'] = 0 unless CharSettings['plate']
CharSettings['glyph'] = 0 unless CharSettings['glyph']
CharSettings['rods'] = 0 unless CharSettings['rods']
CharSettings['boomer'] = 0 unless CharSettings['boomer']
CharSettings['no_trap'] = 0 unless CharSettings['no_trap']
CharSettings['total_trap_count'] = 0.0 unless CharSettings['total_trap_count']
box_was_not_locked = nil
bash_the_box_open = nil
bash_open_boxes = nil
temp_math_number = nil
check_for_lockpicks_etc = nil
quick_maths = nil
offered_tip_amount = nil
minimum_tip_wanted = 0
detect_plinite = nil
temp_id = nil
temp_name = nil
stow_calipers = nil
stow_wedge = nil
critter_level = nil
lock = 0
max_critter_level = 10000
open_or_close_containers = Array.new
buy_locksmith_pouch = nil
cast_704_at_box = nil
detect_plinite_result = nil
box_is_enruned_or_mithril = nil
CharSettings['total_boxes_picked'] = 0 unless CharSettings['total_boxes_picked']
CharSettings['total_time_spent_picking_boxes'] = 0 unless CharSettings['total_time_spent_picking_boxes']
average_picking_time = 0
start_time = 0
before_recommended_pick = nil
i_need_403 = nil
stow_both = nil
ask_worker = nil
start_values_nilled = nil
total_picking_time = nil
total_boxes_count = nil
update_math_information = nil
box_counts_for_math = true
total_boxes_number = nil
reset_math = nil
total_boxes_picked_math = nil
bracers_temp = nil
bracers_name = nil
bracers_tier = nil
nextpick2 = nil
gem_container_close = nil
found_true_lock_difficulty = nil
lockpick_container = nil
lockpick_container_close = nil
broken_lockpick_container = nil
broken_lockpick_container_close = nil
always_use_wedge = nil
wedge_container = nil
wedge_container_close = nil
calipers_container = nil
calipers_container_close = nil
scale_weapon_container = nil
scale_weapon_container_close = nil
locksmiths_container = nil
locksmiths_container_close = nil
open_all_containers = nil
close_all_containers = nil
next_task = nil
roll_amount = nil
number_of_manual_trap_checks_remaining = nil
second_trap_check = nil
check_for_command = nil
start_worker = nil
start_worker2 = nil
gem = nil
reagent = nil
herb = nil
food = nil
uncommon = nil
jewelry = nil
junk = nil
lockpick = nil
magic = nil
scroll = nil
wand = nil
armor = nil
weapon = nil
clothing = nil
other = nil
stow_in_disk = nil
check_for_boxes = nil
remaining_416_casts = nil
stuff_to_do = nil
where_to_stow_box = nil
check_locksmiths_container = nil
putty_remaining = nil
cotton_remaining = nil
vials_remaining = nil
fill_up_locksmith_container = nil
order_number = nil
trash_container = nil
current_vial = nil
use_spell_205 = nil
use_spell_402 = nil
use_spell_403 = nil
use_spell_404 = nil
use_spell_506 = nil
use_spell_613 = nil
use_spell_704 = nil
use_spell_1006 = nil
pop_start = nil
recommended_pick = nil
recommended_pick_modifier = nil
needed_pick_id = nil
before_needed_pick = nil
check_hands_status = nil
current_trap_type = nil
box_is_disarmed = nil
box_is_open = nil
check_for_trap = nil
pop_open_box = nil
disarm_trap = nil
cast_402 = nil
cast_403 = nil
cast_404 = nil
can_use_calipers = nil
pop_boxes_begin = nil
fused_lock_disarm = nil
starting_room = Room.current.id
$scale_trap_weapon_id = nil

$tpick_list_of_box_ids = Array.new
$tpick_copper_wire = nil unless $tpick_copper_wire
$tpick_copper_wire_cost = nil unless $tpick_copper_wire_cost
$tpick_brass_wire = nil unless $tpick_brass_wire
$tpick_brass_wire_cost = nil unless $tpick_brass_wire_cost
$tpick_steel_wire = nil unless $tpick_steel_wire
$tpick_steel_wire_cost = nil unless $tpick_steel_wire_cost
$tpick_gold_wire = nil unless $tpick_gold_wire
$tpick_gold_wire_cost = nil unless $tpick_gold_wire_cost
$tpick_silver_wire = nil unless $tpick_silver_wire
$tpick_silver_wire_cost = nil unless $tpick_silver_wire_cost
$tpick_ora_wire = nil unless $tpick_ora_wire
$tpick_ora_wire_cost = nil unless $tpick_ora_wire_cost
$tpick_mithril_wire = nil unless $tpick_mithril_wire
$tpick_mithril_wire_cost = nil unless $tpick_mithril_wire_cost
$tpick_laje_wire = nil unless $tpick_laje_wire
$tpick_laje_wire_cost = nil unless $tpick_laje_wire_cost
$tpick_alum_wire = nil unless $tpick_alum_wire
$tpick_alum_wire_cost = nil unless $tpick_alum_wire_cost
$tpick_vultite_wire = nil unless $tpick_vultite_wire
$tpick_vultite_wire_cost = nil unless $tpick_vultite_wire_cost
$tpick_rolaren_wire = nil unless $tpick_rolaren_wire
$tpick_rolaren_wire_cost = nil unless $tpick_rolaren_wire_cost
$tpick_veniom_wire = nil unless $tpick_veniom_wire
$tpick_veniom_wire_cost = nil unless $tpick_veniom_wire_cost
$tpick_kelyn_wire = nil unless $tpick_kelyn_wire
$tpick_kelyn_wire_cost = nil unless $tpick_kelyn_wire_cost
$tpick_invar_wire = nil unless $tpick_invar_wire
$tpick_invar_wire_cost = nil unless $tpick_invar_wire_cost
$tpick_golvern_wire = nil unless $tpick_golvern_wire
$tpick_golvern_wire_cost = nil unless $tpick_golvern_wire_cost
$tpick_vaalin_wire = nil unless $tpick_vaalin_wire
$tpick_vaalin_wire_cost = nil unless $tpick_vaalin_wire_cost
get_wire_order_numbers = nil
current_pick_to_check = nil
lockpick_type = nil
current_wire = nil
find_gnomish_lockpick = nil
current_wire_cost = nil
popping = nil
gem_container = nil
start_sorter = nil
toolbenches_room_number = [ '17978', '16574', '17960', '17881' ]
number = nil
solo_or_ground = nil
contents = nil
container = nil
scale_trap_found = nil
gnomish_bracers = nil
found_pick = nil
spin_number = 0
disarm_only = nil
gnomish_bracers_trap_check = nil
gnomish_bracers_trap_check_result = nil
stats_check = nil
$copper_lockpick_id = nil
$steel_lockpick_id = nil
$gold_lockpick_id = nil
$silver_lockpick_id = nil
$mithril_lockpick_id = nil
$ora_lockpick_id = nil
$glaes_lockpick_id = nil
$laje_lockpick_id = nil
$vultite_lockpick_id = nil
$rolaren_lockpick_id = nil
$veniom_lockpick_id = nil
$invar_lockpick_id = nil
$alum_lockpick_id = nil
$golvern_lockpick_id = nil
$kelyn_lockpick_id = nil
$vaalin_lockpick_id = nil
CharSettings['setup_has_been_run'] = nil unless CharSettings['setup_has_been_run']
CharSettings['setup_has_been_run_again'] = nil unless CharSettings['setup_has_been_run_again']
start_with_copper = nil
all_stats_to_check = nil
all_stats_trap_names = nil
math = nil
open_plinites = nil
start_plinites = nil
all_variables_to_check = [ script.vars[1], script.vars[2], script.vars[3], script.vars[4], script.vars[5], script.vars[6], script.vars[7], script.vars[8], script.vars[9], script.vars[10] ]
open_current_plinite = nil
plinite_already_open = nil
cannot_determine_plinite_difficulty = nil

stats_check = proc{
	if CharSettings['total_trap_count'] == 0.0
		echo "No trap information has been recorded yet. Get to checking boxes for traps!"
	else
		number = 0
		all_stats_to_check = [ CharSettings['scarab'], CharSettings['needle'], CharSettings['jaws'], CharSettings['sphere'], CharSettings['crystal'], CharSettings['scales'], CharSettings['sulphur'], CharSettings['cloud'], CharSettings['acid_vial'], CharSettings['springs'], CharSettings['fire_vial'], CharSettings['spores'], CharSettings['plate'], CharSettings['glyph'], CharSettings['rods'], CharSettings['boomer'], CharSettings['no_trap'] ]
		all_stats_trap_names = [ "Scarab         ", "Needle         ", "Jaws           ", "Sphere         ", "Crystal        ", "Scales         ", "Sulphur        ", "Cloud          ", "Acid Vial      ", "Springs        ", "Fire Vial      ", "Spores         ", "Plate          ", "Glyph          ", "Rods           ", "Boomer         ", "No Trap        " ]
		respond "##############################"
		respond "##############################"
		respond "All trap information"
		all_stats_to_check.each { |i|
			math = (((i / CharSettings['total_trap_count'])) * (100)).round(2)
			respond "#{all_stats_trap_names.at(number)} #{i} (#{math}%)"
			number += 1
		}
		respond "Total Trap      #{CharSettings['total_trap_count']}"
		respond "##############################"
		respond "##############################"
	end
		
}

reset_math = proc{
	CharSettings['total_boxes_picked'] = 0
	CharSettings['total_time_spent_picking_boxes'] = 0
}

$tpick_boxes_checked = nil
strongbox_count = 0
box_count = 0
chest_count = 0
trunk_count = 0
coffer_count = 0

gem_number = Array.new
reagent_number = Array.new
herb_number = Array.new
food_number = Array.new
uncommon_number = Array.new
jewelry_number = Array.new
junk_number = Array.new
lockpick_number = Array.new
magic_number = Array.new
scroll_number = Array.new
wand_number = Array.new
armor_number = Array.new
weapon_number = Array.new
clothing_number = Array.new
other_number = Array.new

#The following is just for informational purposes, no need to change anything.

#Pick names and mod values:
#Copper		1.00
#Steel		1.10
#Gold		1.20
#Silver		1.30
#Mithril	1.45
#Ora		1.55
#Glaes		1.60
#Laje		1.75
#Vultite	1.80
#Rolaren	1.90
#Veniom		2.20
#Invar		2.25
#Alum		2.30
#Golvern	2.35
#Kelyn		2.40
#Vaalin		2.50

#Lock names and difficulty
#Primitive					35
#Rudimentary				75
#Extremely Easy				115
#Very Easy					155
#Easy						195
#Very Basic					235
#Fairly Easy				275
#Simple						315
#Fairly Simple				355
#Fairly Plain				395
#Moderately Well-Crafted	435
#Well-Crafted				475
#Tricky						515
#Somewhat Difficult			555
#Moderately Difficult		595
#Very Well-Crafted			635
#Difficult					675
#Extremely Well-Crafted		715
#Very Difficult				755
#Fairly Complicated			795
#Intricate					835
#Amazingly Well-Crafted		875
#Very Complex				915
#Impressively Complicated	955
#Amazingly Intricate		995
#Extremely Difficult		1035
#Extremely Complex			1075
#Masterfully Well-Crafted	1115
#Amazingly Complicated		1155
#Astoundingly Complex		1195
#Incredibly Intricate		1235
#Absurdly Well-Crafted		1275
#Exceedingly Complex		1315
#Absurdly Difficult			1355
#Unbelievably Complicated 	1395
#Masterfully Intricate		1435
#Absurdly Complex			1475
#Impossibly Complex			1515

worker = nil
Room.current.tags.find{ |i| i =~ /meta:boxpool:npc:(.*)/;worker = $1}
worker = GameObj.npcs.find {|i| worker =~ /#{i}/}

table = nil
table = Room.current.tags.find{ |i| i =~ /meta:boxpool:table:(.*)/;table = $1}
if GameObj.loot.find {|i| table =~ /#{i}/}
	table = GameObj.loot.find {|i| table =~ /#{i}/}
else
	table = GameObj.room_desc.find {|i| table =~ /#{i}/}
end

pick_mod = [ 1.00, 1.10, 1.20, 1.30, 1.45, 1.55, 1.60, 1.75, 1.80, 1.90, 2.20, 2.25, 2.30, 2.35, 2.40, 2.50 ]
lock_difficulty = [ 35, 75, 115, 155, 195, 235, 275, 315, 355, 395, 435, 475, 515, 555, 595, 635, 675, 715, 755, 795, 835, 875, 915, 955, 995, 1035, 1075, 1115, 1155, 1195, 1235, 1275, 1315, 1355, 1395, 1435, 1475, 1515 ]
pick_skill = (Skills.to_bonus(Skills.pickinglocks) + Stats.enhanced_dex[1])
pick_lore = [(Stats.level / 2) + (Skills.to_bonus(Skills.pickinglocks) / 10) + (Stats.enhanced_dex[1]) + (Spells.minorelemental / 4), Skills.pickinglocks].min
disarm_skill = (Stats.enhanced_dex[1] + Skills.to_bonus(Skills.disarmingtraps))
if Spell[404].known?
	disarm_lore = (Stats.level / 2) + (Skills.to_bonus(Skills.disarmingtraps) / 10) + (Stats.agi[1] / 2) + (Stats.dis[1] / 2)
else
	disarm_lore = 0
end
(stow_left = nil;stow_right = nil;start_solo = nil;start_others = nil;check_disk = nil;manually_disarm_trap = nil;scaledisarm = nil;plate = nil;measure = nil;pick2 = nil;pick3 = nil;nextpick = nil;open_solo = nil;open_others = nil;need_403 = nil;needed_pick = nil;total_pick_skill = nil;person = nil;box = "box";cast_404 = nil;solo_or_other = nil;always_use_vaalin = nil;wedge_lock = nil;ground_loot = nil;start_ground = nil;current_box = nil;setup = nil;do_trick = nil;calibrate = nil;cast_403 = nil;cast_402 = nil;cast_613 = nil;cast_205 = nil;cast_1006 = nil;cast_506 = nil;calibrate_count = nil;cast_407 = nil;current_box_name = nil;box_opened = true;cant_open_plated_box_count = nil;total_boxes_picked = 0;record_item_data = nil;silver_before = nil;silver_after = nil;wealth_before = nil;wealth_after = nil;silver_gained = 0;trash = nil;garbage_check = nil;trap_difficulty = nil;need_404 = nil;total_trap_skill = nil;broken_lockpick_stow = nil;relock_boxes = nil;do_relock_boxes = nil)

trash_container = /crate|barrel|wastebarrel|casket|bin|receptacle|basket/i

setup = proc{
	CharSettings['setup_has_been_run'] = true
	CharSettings['setup_has_been_run_again'] = true
	$copper_lockpick_id = nil
	$steel_lockpick_id = nil
	$gold_lockpick_id = nil
	$silver_lockpick_id = nil
	$mithril_lockpick_id = nil
	$ora_lockpick_id = nil
	$glaes_lockpick_id = nil
	$laje_lockpick_id = nil
	$vultite_lockpick_id = nil
	$rolaren_lockpick_id = nil
	$veniom_lockpick_id = nil
	$invar_lockpick_id = nil
	$alum_lockpick_id = nil
	$golvern_lockpick_id = nil
	$kelyn_lockpick_id = nil
	$vaalin_lockpick_id = nil
	Gtk.queue {
		$OP_WINDOW = Gtk::Window.new
		$OP_WINDOW.set_icon(@@default_icon)
		$OP_WINDOW.title = "tpick"
		$OP_WINDOW.set_border_width(10)
		$OP_BOX = Gtk::Box.new(:vertical)
		$OP_BOX.set_border_width(5)

		$OP_VERTICAL_BOX1 = Gtk::Box.new(:vertical, 0)
		$OP_VERTICAL_BOX2 = Gtk::Box.new(:vertical, 0)
		$OP_VERTICAL_BOX3 = Gtk::Box.new(:vertical, 0)
		$OP_VERTICAL_BOX4 = Gtk::Box.new(:vertical, 0)
		$OP_VERTICAL_BOX5 = Gtk::Box.new(:vertical, 0)
		$OP_VERTICAL_BOX6 = Gtk::Box.new(:vertical, 0)
		$OP_VERTICAL_BOX7 = Gtk::Box.new(:vertical, 0)
		$OP_VERTICAL_BOX8 = Gtk::Box.new(:vertical, 0)
		$OP_VERTICAL_BOX9 = Gtk::Box.new(:vertical, 0)

		$OP_WINDOW.add($OP_BOX)
		$OP_NOTEBOOK = Gtk::Notebook.new
		$OP_NOTEBOOK.set_show_border(true)
		$OP_BOX.add($OP_NOTEBOOK)
		$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX1, Gtk::Label.new('Lockpicks'))
		$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX2, Gtk::Label.new('More Lockpicks'))
		$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX3, Gtk::Label.new('Containers'))
		$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX4, Gtk::Label.new('Other'))
		$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX5, Gtk::Label.new('More Other'))
		$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX6, Gtk::Label.new('Spells'))
		$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX7, Gtk::Label.new('Experience'))
		$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX8, Gtk::Label.new('Speech'))
		$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX9, Gtk::Label.new('Popping'))
		$OP_ENTRY = Hash.new 
		$OP_TABLE_SIZE = Hash.new
	}

	Gtk.queue {
		$OP_TABLE1 = Gtk::Table.new(6, 3, false)
		$OP_TABLE1.row_spacings=3
		$OP_TABLE1.column_spacings=3
		$OP_VERTICAL_BOX1.pack_start($OP_TABLE1, :expand => false, :fill => false, :padding => 0)

		$OP_TABLE2 = Gtk::Table.new(6, 3, false)
		$OP_TABLE2.row_spacings=3
		$OP_TABLE2.column_spacings=3
		$OP_VERTICAL_BOX2.pack_start($OP_TABLE2, :expand => false, :fill => false, :padding => 0)

		$OP_TABLE3 = Gtk::Table.new(6, 3, false)
		$OP_TABLE3.row_spacings=3
		$OP_TABLE3.column_spacings=3
		$OP_VERTICAL_BOX3.pack_start($OP_TABLE3, :expand => false, :fill => false, :padding => 0)

		$OP_TABLE4 = Gtk::Table.new(6, 3, false)
		$OP_TABLE4.row_spacings=3
		$OP_TABLE4.column_spacings=3
		$OP_VERTICAL_BOX4.pack_start($OP_TABLE4, :expand => false, :fill => false, :padding => 0)

		$OP_TABLE5 = Gtk::Table.new(6, 3, false)
		$OP_TABLE5.row_spacings=3
		$OP_TABLE5.column_spacings=3
		$OP_VERTICAL_BOX5.pack_start($OP_TABLE5, :expand => false, :fill => false, :padding => 0)

		$OP_TABLE6 = Gtk::Table.new(6, 3, false)
		$OP_TABLE6.row_spacings=3
		$OP_TABLE6.column_spacings=3
		$OP_VERTICAL_BOX6.pack_start($OP_TABLE6, :expand => false, :fill => false, :padding => 0)

		$OP_TABLE7 = Gtk::Table.new(6, 3, false)
		$OP_TABLE7.row_spacings=3
		$OP_TABLE7.column_spacings=3
		$OP_VERTICAL_BOX7.pack_start($OP_TABLE7, :expand => false, :fill => false, :padding => 0)

		$OP_TABLE8 = Gtk::Table.new(6, 3, false)
		$OP_TABLE8.row_spacings=3
		$OP_TABLE8.column_spacings=3
		$OP_VERTICAL_BOX8.pack_start($OP_TABLE8, :expand => false, :fill => false, :padding => 0)

		$OP_TABLE9 = Gtk::Table.new(6, 3, false)
		$OP_TABLE9.row_spacings=3
		$OP_TABLE9.column_spacings=3
		$OP_VERTICAL_BOX9.pack_start($OP_TABLE9, :expand => false, :fill => false, :padding => 0)
	}

	def self.add_label_entry(table, label, variable)
		size = $OP_TABLE_SIZE[table] || 0

		label = Gtk::Label.new(label)
		align = Gtk::Alignment.new 1, 0, 0, 0
		align.set_padding(4, 0, 3, 4)
		align.add(label)
		table.attach(align, 0, 1, size, size + 1)

		entry = Gtk::Entry.new
		entry.text = UserVars.tpick[variable].to_s
		entry.set_width_request(157)
		table.attach(entry, 1, 2, size, size + 1)

		$OP_ENTRY[variable] = entry
		$OP_TABLE_SIZE[table] += 1
	end

	Gtk.queue {
		$OP_ENTRY = Hash.new
		add_label_entry($OP_TABLE1, "Copper Lockpick", 'copper')
		add_label_entry($OP_TABLE1, "Steel Lockpick", 'steel')
		add_label_entry($OP_TABLE1, "Gold Lockpick", 'gold')
		add_label_entry($OP_TABLE1, "Silver Lockpick", 'silver')
		add_label_entry($OP_TABLE1, "Mithril Lockpick", 'mithril')
		add_label_entry($OP_TABLE1, "Ora Lockpick", 'ora')
		add_label_entry($OP_TABLE1, "Glaes Lockpick", 'glaes')
		add_label_entry($OP_TABLE1, "Laje Lockpick", 'laje')
		add_label_entry($OP_TABLE2, "Vultite Lockpick", 'vultite')
		add_label_entry($OP_TABLE2, "Rolaren Lockpick", 'rolaren')
		add_label_entry($OP_TABLE2, "Veniom Lockpick", 'veniom')
		add_label_entry($OP_TABLE2, "Invar Lockpick", 'invar')
		add_label_entry($OP_TABLE2, "Alum Lockpick", 'alum')
		add_label_entry($OP_TABLE2, "Golvern Lockpick", 'golvern')
		add_label_entry($OP_TABLE2, "Kelyn Lockpick", 'kelyn')
		add_label_entry($OP_TABLE2, "Vaalin Lockpick", 'vaalin')
		add_label_entry($OP_TABLE3, "Lockpick Container", 'lockpick_container')
		add_label_entry($OP_TABLE3, "Broken Lockpick Container", 'broken_lockpick_container')
		add_label_entry($OP_TABLE3, "Wedge Container", 'wedge_container')
		add_label_entry($OP_TABLE3, "Calipers Container", 'calipers_container')
		add_label_entry($OP_TABLE3, "Scale Weapon Container", 'scale_weapon_container')
		add_label_entry($OP_TABLE3, "Locksmith's Container", 'locksmiths_container')
		add_label_entry($OP_TABLE3, "Gem Container", 'gem_container')
		#add_label_entry($OP_TABLE4, "Run silently", 'run_silently')
		add_label_entry($OP_TABLE4, "Gnomish Bracer", 'gnomish_bracer')
		add_label_entry($OP_TABLE4, "Bashing Weapon", 'bashing_weapon')
		add_label_entry($OP_TABLE4, "Scale Trap Weapon", 'scale_trap_weapon')
		add_label_entry($OP_TABLE4, "Trap Roll", 'trap_roll')
		add_label_entry($OP_TABLE4, "Lock Roll", 'lock_roll')
		add_label_entry($OP_TABLE4, "Vaalin Lock Roll", 'vaalin_lock_roll')
		add_label_entry($OP_TABLE5, "Trick", 'trick')
		add_label_entry($OP_TABLE5, "Log", 'log')
		add_label_entry($OP_TABLE5, "Trash boxes", 'trash_boxes')
		add_label_entry($OP_TABLE5, "Calibrate on startup", 'calibrate')
		add_label_entry($OP_TABLE5, "Calibrate count", 'calibratecount')
		add_label_entry($OP_TABLE5, "Auto Bundle Vials", 'auto_bundle_vials')
		add_label_entry($OP_TABLE5, "Auto repair bent lockpicks", 'auto_repair_bent_lockpicks')
		add_label_entry($OP_TABLE5, "Number of times to check for traps", 'number_of_times_to_check_for_traps')
		add_label_entry($OP_TABLE6, "Light (205)", 'always_use_205')
		add_label_entry($OP_TABLE6, "Presence (402)", 'always_use_402')
		add_label_entry($OP_TABLE6, "Lock Pick Enhancement (403)", 'always_use_403')
		add_label_entry($OP_TABLE6, "Disarm Enhancement (404)", 'always_use_404')
		add_label_entry($OP_TABLE6, "Unlock (407)", 'always_use_407')
		add_label_entry($OP_TABLE6, "Haste (506)", 'always_use_506')
		add_label_entry($OP_TABLE6, "Self Control (613)", 'always_use_613')
		add_label_entry($OP_TABLE6, "Song of Luck (1006)", 'always_use_1006')
		add_label_entry($OP_TABLE7, "Use Vaalin when Fried", 'use_vaalin_when_fried')
		add_label_entry($OP_TABLE7, "Rest at Percent", 'rest_percent')
		add_label_entry($OP_TABLE7, "Pick at Percent", 'pick_percent')
		add_label_entry($OP_TABLE8, "Ready", 'ready')
		add_label_entry($OP_TABLE8, "Can't Open Box", 'cant_open_box')
		add_label_entry($OP_TABLE9, "Phase (704)", 'always_use_704')
		add_label_entry($OP_TABLE9, "Number of 416 casts", 'number_of_416_casts')
		add_label_entry($OP_TABLE9, "Only disarm safe", 'only_disarm_safe')
	}

	def self.add_checkbox(table, x_pos, label, variable, default = false)
		size = $OP_TABLE_SIZE[table] || 0
		checkbox = Gtk::CheckButton.new label
		value = UserVars.tpick[variable].nil? ? default : UserVars.tpick[variable]
		checkbox.set_active(value)
		table.attach(checkbox, x_pos, x_pos + 1, size, size + 1)
		$OP_ENTRY[variable] = checkbox
		$OP_TABLE_SIZE[table] += 1 if x_pos == 1
	end
        
	Gtk.queue {
		$OP_WINDOW.signal_connect("delete_event") {
			$OP_SETUP_COMPLETED = true
		}
	}
        
	Gtk.queue {
#		$OP_TOOLTIPS = Gtk::Tooltips.new
#		$OP_TOOLTIPS.enable

		label = Gtk::Label.new
		label.set_markup("Enter the FULL name of your lockpicks above, NOT including the words 'a' or 'an'.  If you don't have a particular lockpick use the next best lockpick.\nFor example if you don't have a steel lockpick then put the name of your gold lockpick in both the steel and gold lockpick variables.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$OP_TABLE1.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("Enter the FULL name of your lockpicks above, NOT including the words 'a' or 'an'.  If you don't have a particular lockpick use the next best lockpick.\nFor example if you don't have a steel lockpick then put the name of your gold lockpick in both the steel and gold lockpick variables.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$OP_TABLE2.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("Enter the FULL name of your container above where items can be found and will be stored, DON'T include the starting words of 'a' or 'an'.\nEnter <b>,close</b> after any container you want script to close when finished.\nFor example: <b>pack,close</b>\n<b>Broken Lockpick Container:</b>  Container where script will store your broken lockpicks.\n<b>Locksmith's Container:</b>  Container where putty and cotton balls are found.\n<b>Gem Container</b>  Enter name of container where script should stow all gems found from looting boxes.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$OP_TABLE3.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("<b>Gnomish Bracer:</b>  Enter name and tier of your gnomish bracer (example: bracer,1), <b>nil</b> if none.\n<b>Bashing Weapon:</b>  Name of weapon to use for bashing boxes, <b>nil</b> if none.\n<b>Scale Trap Weapon:</b>  FULL name of weapon you use for disarming scale traps, not including 'a' or 'an'.\n<b>Trap Roll:</b>  Determines what difficulty boxes you want to attempt.\nSet to 0 to never try anything higher than your total disarm skill + lore bonus.\nSetting to 10 would attempt traps 10 points higher than your disarm skill + lore bonus.\nSetting to -10 would only attempt traps that are a maximum of 10 points lower than your disarm skill + lore bonus.\nSet this value to whatever number you want. A value of 1000 would attempt to disarm all traps.\nScript will always use 404 if it determines you need the spell to disarm a trap.\n<b>Lock Roll:</b>  Maximum roll allowed before moving to a higher lockpick.\nExample if this value is 50 and you roll a 60 and didn't pick the lock the script will move to the next lockpick. 50 is a good starting number.\n<b>Vaalin Lock Roll:</b>  Same as above but just for vaalin picks if you want to attempt to pick locks with a higher needed roll than other lockpicks. 80 is a good starting number.\nSet to 1000 to always try picking a lock with a vaalin lockpick before moving on to a wedge or 407.\n<b>This number should be equal or higher than Lock Roll.</b>")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$OP_TABLE4.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("<b>Trick:</b>  Trick to use when picking locks. Enter: spin, twist, turn, twirl, toss, bend or flip.  Enter <b>pick</b> if you don't want to use a trick.\n<b>Log:</b>  Enter <b>yes</b> to display a summary of all loot found when done.\n<b>Trash boxes:</b>  Enter <b>yes</b> to dispose of empty boxes if possible, <b>no</b> will drop them on the ground, <b>save</b> STOWS empty boxes.\n<b>Calibrate on startup:</b>  Enter <b>yes</b> to calibrate your calipers whenever the script is started and you are measuring locks, <b>no</b> to skip calibrating or you have less than 40 ranks of lock mastery.\n<b>Calibrate Count:</b>  Will calibrate your calipers every time you pick this many boxes. (enter 999 to never calibrate)\n<b>Auto Bundle Vials:</b> Enter <b>yes</b> to have script bundle vials you get from disarming traps into your locksmith's container.\n<b>Auto repair bent lockpicks:</b>  Enter <b>yes</b> to have script automatically repair lockpicks after they have been bent. Only works if you have learned lmas repair.\n<b>Number of times to check for traps:</b>  How many times you want script to manually check for traps.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$OP_TABLE5.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("Enter <b>yes</b> for any spells you want to keep on while disarming/picking, <b>no</b> for any spells you don't want to cast.\nIf 403 and 404 are set to <b>no</b> the script will cast the spells when needed (after a failure or for a very high lock) and if you know the spell.\nSet 403 and 404 to <b>cancel</b> if you want these spells stopped when starting on a new box.\nSet 403 to <b>never</b> to NEVER use 403.\nIf <b>407</b> is set to <b>plate</b> the script will attempt to open plated boxes (except mithril or enruned) with 407 if you have no acid vials or wedges.\nIf <b>407</b> is set to <b>all</b> the script will attempt to open all boxes (except mithril and enruned) with 407.\nEnter <b>no</b> for <b>407</b> to skip using 407 on boxes.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$OP_TABLE6.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("<b>Use Vaalin when Fried:</b>  Enter <b>yes</b> to always use vaalin if you're fried.\n<b>Rest at Percent:</b>  Script will pause when your mind reaches this amount or higher.  Enter <b>200</b> to never rest.\n<b>Pick at Percent:</b>  Will start picking when your mind reaches this amount or lower.  Enter <b>100</b> to always pick.\nDoes not work when using OTHER command line.\nUse the following amounts\nmust rest:  100\nnumbed:  90\nbecoming numbed:  75\nmuddled:  62\nclear:  50\nfresh and clear:  25\nclear as a bell:  0")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$OP_TABLE7.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("Enter <b>nil</b> for any option where you don't want to speak.\n<b>Ready:</b>  What to say when ready to be handed boxes from another person. Example: <b>Ready.</b>\n<b>Can't Open Box:</b>  What to say when you can't open a box for another person. Example: <b>Sorry can't open this box.</b>")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$OP_TABLE8.attach(align, 1, 2, 8, 9)

		label = Gtk::Label.new
		label.set_markup("<b>Phase (704):</b>  Enter <b>yes</b> to use Phase (704) on each box to check for glyph traps, <b>no</b> to skip Phase.\n<b>Number of 416 casts:</b>  Number of times you want to check a box for traps using Piercing Gaze (416).\n<b>Only disarm safe:</b>  Some traps can be bypassed altogether when using 407 to open the box and some traps are always safe to use 408 on.\nHowever some traps have a chance of being set off when using 408. \nEnter <b>yes</b> here to skip boxes with traps that are not 100% safe, <b>no</b> to attempt disarming them with 408.\nSome traps are never safe to use 408 on and the script will always skip these boxes no matter what value you enter here.")
		align = Gtk::Alignment.new(1, 0, 0, 0)
		align.set_padding(50, 0, 0, 40)
		align.add(label)
		$OP_TABLE9.attach(align, 1, 2, 8, 9)

		$OP_WINDOW.show_all
	}
        
	$OP_SETUP_COMPLETED = false
	until($OP_SETUP_COMPLETED)
		sleep 1
	end
	
	UserVars.tpick ||= Hash.new
	$OP_ENTRY.keys.each { |key|
		if( $OP_ENTRY[key].class.to_s =~ /CheckButton/ )
			value = $OP_ENTRY[key].active?
			UserVars.tpick[key] = $OP_ENTRY[key].active?
		else
			if(key == 'wounded_eval')
				UserVars.tpick[key] = $OP_ENTRY[key].text
			else
				UserVars.tpick[key] = $OP_ENTRY[key].text.strip.downcase
			end
		end
	}

	UserVars.save()
        
	Gtk.queue {
		$OP_WINDOW.destroy
	}
}

def tpick_cast_spells (number)
	if Spell[number].known? && !Spell[number].active?
		until Spell[number].active?
			if !Spell[number].affordable?
				echo "Waiting for mana."
				wait_until { Spell[number].affordable? }
			end
			Spell[number].cast
			sleep 0.2
		end
	end
end

def tpick_prep_spell(number, name)
	if Spell[number].known?
		if !Spell[number].affordable?
			echo "Waiting for mana."
			wait_until { Spell[number].affordable? }
		end
		until checkprep == "#{name}"
			waitrt?
			waitcastrt?
			fput "release" if checkprep !~ /None|#{name}/i
			fput "prep #{number}"
			sleep 0.2
		end
	end
end

def tpick_drop_box(current_box)
	if GameObj.right_hand.id == current_box.id
		until checkright.nil?
			waitrt?
			fput "drop ##{current_box.id}"
			sleep 0.2
		end
	else
		until checkleft.nil?
			waitrt?
			fput "drop ##{current_box.id}"
			sleep 0.2
		end
	end
end

def tpick_get_box(current_box)
	until GameObj.right_hand.id == current_box.id || GameObj.left_hand.id == current_box.id
		waitrt?
		fput "get ##{current_box.id}"
		sleep 0.2
	end
end

def tpick_stop_403_404		
	waitrt?
	fput "stop 403" if Spell[403].active? && UserVars.tpick["always_use_403"] == "cancel"
	fput "stop 404" if Spell[404].active? && UserVars.tpick["always_use_404"] == "cancel"
end

def tpick_stow_box(current_box)
	until GameObj.right_hand.id != current_box.id && GameObj.left_hand.id != current_box.id
		waitrt?
		fput "stow ##{current_box.id}"
		sleep 0.2
	end
end

def tpick_say_cant
	fput "say #{UserVars.tpick["cant_open_box"]}" if UserVars.tpick["cant_open_box"] != "nil"
end

ask_worker = proc{
	waitrt?
	result = dothistimeout "ask ##{worker.id} to check", 3, /If you want to give up\, ASK me to CHECK it again within 30 seconds\.\"|Here\'s your payment of|You aren\'t working on a job\.|Too tough for ya\, eh\?/
	if result =~ /If you want to give up\, ASK me to CHECK it again within 30 seconds\.\"|Here\'s your payment of|You aren\'t working on a job\.|Too tough for ya\, eh\?/
		nil
	elsif result.nil?
		echo "Didn't recognize game line I was looking for, trying again."
		ask_worker.call
	end
}

stow_calipers = proc{
	until GameObj.right_hand.name !~ /calipers/ && GameObj.left_hand.name !~ /calipers/
		waitrt?
		fput "put my calipers in ##{calipers_container.id}"
		sleep 0.1
	end
}

stow_wedge = proc{
	until GameObj.right_hand.name !~ /wedge/ && GameObj.left_hand.name !~ /wedge/
		waitrt?
		fput "put my wedge in ##{wedge_container.id}"
		sleep 0.1
	end
}

open_current_plinite = proc{
	stow_left.call
	waitrt?
	fput "pluck ##{current_box.id}"
	stow_both.call
}

start_plinites = proc{
	$tpick_list_of_box_ids.each{ |plinite|
		stow_both.call
		plinite_already_open = nil
		cannot_determine_plinite_difficulty = nil
		until GameObj.right_hand.id == plinite || GameObj.left_hand.id == plinite
			waitrt?
			fput "get ##{plinite}"
			sleep 0.2
		end
		current_box = GameObj.right_hand if GameObj.right_hand.name =~ /plinite/
		current_box = GameObj.left_hand if GameObj.left_hand.name =~ /plinite/
		detect_plinite.call
	}
}

detect_plinite_result = proc{
	waitrt?
	result = dothistimeout "detect ##{current_box.id}", 3, /It looks like it would be.*\(\-(\d+)\)\.|You struggle to determine the difficulty of the extraction \(somewhere between .* and \-(\d+)\)\.|You promptly discover that the core has already been removed\.|You are unable to determine the difficulty of the extraction\.|You promptly discover that the core has already been extracted and merely needs to be PLUCKed from the tip of the shard\./
	if result =~ /It looks like it would be.*\(\-(\d+)\)\./ || result =~ /You struggle to determine the difficulty of the extraction \(somewhere between .* and \-(\d+)\)\./
		lock = $1.to_i
	elsif result =~ /You promptly discover that the core has already been removed\./
		echo "This plinite has already been extracted."
		stow_both.call
		plinite_already_open = true
	elsif result =~ /You are unable to determine the difficulty of the extraction\./
		cannot_determine_plinite_difficulty = true
		lock = 1000000
	elsif result =~ /You promptly discover that the core has already been extracted and merely needs to be PLUCKed from the tip of the shard\./
		open_current_plinite.call
		plinite_already_open = true
	elsif result.nil?
		detect_plinite_result.call
	end
}

detect_plinite = proc{
	i_need_403 = nil
	detect_plinite_result.call
	if plinite_already_open == nil
		total_pick_skill = (pick_skill + pick_lore) * 2.50
		if lock > (total_pick_skill + UserVars.tpick["vaalin_lock_roll"].to_i) || cannot_determine_plinite_difficulty
			if solo_or_other == "worker"
				if cannot_determine_plinite_difficulty
					echo "Can't extract this plinite because difficulty could not be determined."
				else
					echo "Can't extract this plinite based on my calculations. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
				end
				cannot_determine_plinite_difficulty = nil
				ask_worker.call
			else
				if cannot_determine_plinite_difficulty
					echo "Can't extract this plinite because difficulty could not be determined, OPENing it instead."
				else
					echo "Can't extract this plinite, OPENing it instead. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
				end
				cannot_determine_plinite_difficulty = nil
				waitrt?
				fput "open ##{current_box.id}"
			end
		else
			pick_mod.each do |i|
				total_pick_skill = (pick_skill + pick_lore)
				if (total_pick_skill) * 2.50 - lock + UserVars.tpick["lock_roll"].to_i < 100
					needed_pick = UserVars.tpick["vaalin"]
					needed_pick_id = $vaalin_lockpick_id
					need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
					need_404 = "yes" unless UserVars.tpick["always_use_404"] == "never"
					i_need_403 = true unless UserVars.tpick["always_use_403"] == "never"
					number = 15
					break
				else
					total_pick_skill = (pick_skill) * i
					if total_pick_skill - lock + UserVars.tpick["lock_roll"].to_i < 100
						number += 1
						unless UserVars.tpick["always_use_403"] == "never"
							i_need_403 = true if number > 14
						end
					else
						break
					end
				end
			end
			if i_need_403
				number = 0
				need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
				need_404 = "yes" unless UserVars.tpick["always_use_404"] == "never"
				pick_mod.each do |i|
					total_pick_skill = (pick_skill + pick_lore) * i
					if total_pick_skill - lock + UserVars.tpick["lock_roll"].to_i < 100
						number += 1
					else
						break
					end
				end
			end
			if number == 0
				needed_pick = UserVars.tpick["copper"]
				needed_pick_id = $copper_lockpick_id
				recommended_pick = "copper"
				recommended_pick_modifier = 1.00
			elsif number == 1
				needed_pick = UserVars.tpick["steel"]
				needed_pick_id = $steel_lockpick_id
				recommended_pick = "steel"
				recommended_pick_modifier = 1.10
			elsif number == 2
				needed_pick = UserVars.tpick["gold"]
				needed_pick_id = $gold_lockpick_id
				recommended_pick = "gold"
				recommended_pick_modifier = 1.20
			elsif number == 3
				needed_pick = UserVars.tpick["silver"]
				needed_pick_id = $silver_lockpick_id
				recommended_pick = "silver"
				recommended_pick_modifier = 1.30
			elsif number == 4
				needed_pick = UserVars.tpick["mithril"]
				needed_pick_id = $mithril_lockpick_id
				recommended_pick = "mithril"
				recommended_pick_modifier = 1.45
			elsif number == 5
				needed_pick = UserVars.tpick["ora"]
				needed_pick_id = $ora_lockpick_id
				recommended_pick = "ora"
				recommended_pick_modifier = 1.55
			elsif number == 6
				needed_pick = UserVars.tpick["glaes"]
				needed_pick_id = $glaes_lockpick_id
				recommended_pick = "glaes"
				recommended_pick_modifier = 1.60
			elsif number == 7
				needed_pick = UserVars.tpick["laje"]
				needed_pick_id = $laje_lockpick_id
				recommended_pick = "laje"
				recommended_pick_modifier = 1.75
			elsif number == 8
				needed_pick = UserVars.tpick["vultite"]
				needed_pick_id = $vultite_lockpick_id
				recommended_pick = "vultite"
				recommended_pick_modifier = 1.80
			elsif number == 9
				needed_pick = UserVars.tpick["rolaren"]
				needed_pick_id = $rolaren_lockpick_id
				recommended_pick = "rolaren"
				recommended_pick_modifier = 1.90
			elsif number == 10
				needed_pick = UserVars.tpick["veniom"]
				needed_pick_id = $veniom_lockpick_id
				recommended_pick = "veniom"
				recommended_pick_modifier = 2.20
			elsif number == 11
				needed_pick = UserVars.tpick["invar"]
				needed_pick_id = $invar_lockpick_id
				recommended_pick = "invar"
				recommended_pick_modifier = 2.25
			elsif number == 12
				needed_pick = UserVars.tpick["alum"]
				needed_pick_id = $alum_lockpick_id
				recommended_pick = "alum"
				recommended_pick_modifier = 2.30
			elsif number == 13
				needed_pick = UserVars.tpick["golvern"]
				needed_pick_id = $golvern_lockpick_id
				recommended_pick = "golvern"
				recommended_pick_modifier = 2.35
			elsif number == 14
				needed_pick = UserVars.tpick["kelyn"]
				needed_pick_id = $kelyn_lockpick_id
				recommended_pick = "kelyn"
				recommended_pick_modifier = 2.40
			elsif number == 15
				needed_pick = UserVars.tpick["vaalin"]
				needed_pick_id = $vaalin_lockpick_id
				recommended_pick = "vaalin"
				recommended_pick_modifier = 2.50
			end
			echo "Recommended lock pick: #{recommended_pick} with a modifier of #{recommended_pick_modifier}"
			if need_403 == "yes"
				echo "Recommend 403: Yes"
				echo "Your calculated lockpicking skill: #{pick_skill}"
				echo "Your calculated lockpicking lore: #{pick_lore}"
				temp_math_number = pick_skill + pick_lore
			else
				echo "Recommend 403: No"
				echo "Your calculated lockpicking skill: #{pick_skill}"
				temp_math_number = pick_skill
			end
			quick_maths = (temp_math_number * recommended_pick_modifier).truncate
			echo "Your total picking skill for this attempt is: #{quick_maths}"
			echo "Lock difficulty: #{lock}"
			pick2.call
		end	
	end
}

pop_start = proc{
	$tpick_list_of_box_ids.each{ |box|
		current_box = box
		pop_boxes_begin.call
	}
	check_disk.call
}

cast_704_at_box = proc{
	waitrt?
	waitcastrt?
	tpick_prep_spell(704, "Phase")
	result = dothistimeout "cast at ##{current_box.id}", 3, /resists the effects of your magic|appears lighter|then stabilizes|but quickly returns to normal|Roundtime/
	if result =~ /resists the effects of your magic/
		echo "Box has a glyph trap and cannot be opened."
		tpick_drop_box(current_box) if solo_or_other == "ground"
		where_to_stow_box.call if solo_or_other == "solo"
		box_opened = nil
	elsif result =~ /appears lighter|then stabilizes|but quickly returns to normal|Roundtime/
		echo "Box has no glyph trap. Checking for other traps."
		tpick_drop_box(current_box)
		tpick_get_box(current_box) if solo_or_other != "ground"
		check_for_trap.call
	elsif result.nil?
		cast_704_at_box.call
	end
}

pop_boxes_begin = proc{
	stow_both.call
	until checkright
		fput "get ##{current_box}"
		sleep 0.2
	end
	current_box = GameObj.right_hand
	start_time = Time.now
	remaining_416_casts = UserVars.tpick["number_of_416_casts"].to_i
	stuff_to_do.call
	check_for_command = "glance"
	check_hands_status = nil
	check_for_boxes.call
	wait_until { check_hands_status }
	if check_hands_status == "mithril or enruned"
		echo "Can't open this box because it is mithril or enruned."
		waitrt?
		tpick_drop_box(current_box) if solo_or_other == "ground"
		where_to_stow_box.call if solo_or_other == "solo"
		box_opened = nil
	elsif check_hands_status == "empty"
		echo "No box was found in your hands."
		exit
	else
		if use_spell_704
			cast_704_at_box.call
		else
			echo "Checking for traps."
			tpick_drop_box(current_box) if solo_or_other == "ground"
			check_for_trap.call
		end
	end
}

where_to_stow_box = proc{
	if solo_or_other == "solo"
		if stow_in_disk
			fput "put ##{current_box.id} in #{checkname} disk"
		else
			tpick_stow_box(current_box)
		end
	end
}

gnomish_bracers_trap_check_result = proc{
	waitrt?
	result = dothistimeout "rub my #{gnomish_bracers}", 3, /begins to glow with a deep red light|begins to glow with a bright green light/
	if result =~ /begins to glow with a deep red light/
		waitrt?
		manually_disarm_trap.call
	elsif result =~ /begins to glow with a bright green light/
		waitrt?
		if (disarm_only)
			if (bash_open_boxes)
				bash_the_box_open.call
			else
				box_counts_for_math = nil
				tpick_drop_box(current_box)
			end
		else
			measure.call
		end
	elsif result.nil?
		gnomish_bracers_trap_check_result.call
	end
}

gnomish_bracers_trap_check = proc{
	if solo_or_other != "ground" && solo_or_other != "worker"
		wait_until { GameObj.right_hand.id != nil}
		current_box = GameObj.right_hand
	end
	tpick_get_box(current_box) if solo_or_other == "ground"
	if solo_or_other == "worker" && current_box.nil?
		dothistimeout "look on ##{table.id}", 3, /^On the/
		table.contents.each{ |item|
			if item.name =~ /#{checkname}/
				current_box = item
				break
			end
		}
		wait_until { current_box }
		sleep 1
	end
	gnomish_bracers_trap_check_result.call
}

check_for_trap = proc{
	tpick_cast_spells (402)
	tpick_cast_spells (404)
	current_trap_type = nil
	tpick_prep_spell(416, "Piercing Gaze")
	fput "cast at ##{current_box.id}"
	while line = get
		if line =~ /Peering closely into the lock\, you spy.*scarab wedged into the lock mechanism\./
			current_trap_type = "scarab"
			CharSettings['scarab'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You notice what appears to be a sharp sliver of metal nestled in a hole next to the lock plate\./
			current_trap_type = "needle"
			CharSettings['needle'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You notice a discolored oval ring around the outside of the.*which makes you suspicious\.\s+Your suspicions are confirmed when you look inside the keyhole and notice the spring\-loaded jaws pressed flush against the.*walls\./
			current_trap_type = "jaws"
			CharSettings['jaws'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You see a tiny sphere imbedded in the lock mechanism\./
			current_trap_type = "sphere"
			CharSettings['sphere'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You can see a small crystal imbedded in the locking mechanism\./
			current_trap_type = "crystal"
			CharSettings['crystal'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You see a cord stretched between the lid and case\./
			current_trap_type = "scales"
			CharSettings['scales'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Peering through the .*\, you notice that the lock casing is coated with a rough\, grainy substance\, and a small bladder is wedged between the tumblers of the lock\./
			current_trap_type = "sulphur"
			CharSettings['sulphur'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of liquid and a tiny hammer device which seems poised to shatter it if the lock is tampered with\./
			current_trap_type = "cloud"
			CharSettings['cloud'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You notice what appears to be a tiny vial placed just past the tumblers of the lock mechanism\.\s+It appears that any tampering with the lock mechanism will cause the tumblers to crush the vial\./
			current_trap_type = "acid vial"
			CharSettings['acid_vial'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Peering through the .*\, you notice that the hinges have some springs incorporated into the design in an unusual fashion\./
			current_trap_type = "springs"
			CharSettings['springs'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of fire\-red liquid and a tiny hammer device which seems poised to shatter it if the lock is tampered with\./
			current_trap_type = "fire vial"
			CharSettings['fire_vial'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You see a thin tube extending from the lock mechanism down into the .*\.\s+The tube appears to be filled with a greenish powder\./
			current_trap_type = "spores"
			CharSettings['spores'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /There appears to be a plate over the lock\, sealing it and preventing any access to the tumblers\./
			current_trap_type = "plate"
			CharSettings['plate'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Near the lock mechanism\, you notice a pair of small metal rods a hair\'s width from rubbing together\./
			current_trap_type = "rods"
			CharSettings['rods'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /The inside chamber is lined with some unidentifiable substance\./
			current_trap_type = "boomer"
			CharSettings['boomer'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /You gaze at the.*but your vision is obscured\./
			current_trap_type = "check again"
		elsif line =~ /Suddenly a dark splotch erupts from the lock mechanism and envelops you\!  Time seems to slow down and almost stop\.\.\./
			current_trap_type = "glyph"
			CharSettings['glyph'] += 1
			CharSettings['total_trap_count'] += 1
		elsif line =~ /Roundtime/
			break
		end
	end
	if current_trap_type != "check again" && current_trap_type != nil
		echo "Found a #{current_trap_type} trap."
	end
	if current_trap_type == "check again"
		echo "Failed detecting a trap, trying again."
		check_for_trap.call
	elsif current_trap_type == "needle" || current_trap_type == "jaws" || current_trap_type == "plate"
		echo "Trap is safe to skip disarming."
		pop_open_box.call
	elsif current_trap_type == "crystal" || current_trap_type == "springs"
		echo "Trap is safe to use 408 on. Must be disarmed before popping."
		disarm_trap.call
	elsif current_trap_type == "scarab" || current_trap_type == "sphere" || current_trap_type == "scales" || current_trap_type == "acid vial" || current_trap_type == "fire vial" || current_trap_type == "spores" || current_trap_type == "boomer" || current_trap_type == "cloud" || current_trap_type == "rods"
		echo "408 might set off trap. Must be disarmed before popping."
		if UserVars.tpick["only_disarm_safe"] == "yes"
			echo "Skipping box due to tpick setting Only disarm safe is set to yes."
			where_to_stow_box.call
			box_opened = nil
		else
			disarm_trap.call
		end
	elsif current_trap_type == "sulphur"
		echo "Skipping box because 408 will set this trap off."
		where_to_stow_box.call
		box_opened = nil
	elsif current_trap_type == "glyph"
		echo "The box had a glyph trap on it. Taking you back to the room you started in."
		while checkroom =~ /Temporal Rift/
			move 'e'
			sleep 0.1
		end
		sleep 0.5
		start_script "go2", [starting_room]
		wait_while{ running?('go2') }
		echo "This box has a glyph trap and cannot be opened."
		where_to_stow_box.call
		box_opened = nil
	elsif current_trap_type == nil
		echo "No trap found."
		remaining_416_casts -= 1
		if remaining_416_casts < 1
			CharSettings['no_trap'] += 1
			CharSettings['total_trap_count'] += 1
			pop_open_box.call
		else
			echo "416 casts remaining: #{remaining_416_casts}."
			check_for_trap.call
		end
	end
}

fused_lock_disarm = proc{
	if Char.prof == 'Rogue'
		echo "Going to try wedging this box open."
		wedge_lock.call
	elsif Char.prof != 'Rogue' and !Spell[407].known?
		echo "Can't open this box."
		if solo_or_other == "solo"
			where_to_stow_box.call
		elsif solo_or_other == "other"
			tpick_say_cant
			open_others.call
		elsif solo_or_other == "ground"
			cant_open_plated_box_count += 1
			box_opened = nil
		elsif solo_or_other == "worker"
			nil
		end
	elsif Char.prof != 'Rogue' and Spell[407].known?
		tpick_get_box(current_box) if solo_or_other == "ground"
		echo "Going to try popping this box."
		cast_407.call
	end
}

pop_open_box = proc{
	box_is_open = nil
	echo "Popping box."
	loop{
		tpick_cast_spells (403) unless UserVars.tpick["always_use_403"] == "never"
		tpick_prep_spell(407, "Unlock")
		fput "cast at ##{current_box.id}"
		waitrt?
		while line = get
			if line =~ /The.*vibrates slightly but nothing else happens\.|Suddenly\, part of the.*face breaks away and a pair of gleaming jaws snap shut before the lockplate\!\s+Good thing your hand wasn\'t there\!|Roundtime/
				break
			elsif line =~ /You hear a soft click from the.*and it suddenly flies open\.|But the.*is already open\./
				box_is_open = true
				break
			end
		end
		break if box_is_open
	}
	open_solo.call if solo_or_other != "ground"
}

disarm_trap = proc{
	box_is_disarmed = nil
	loop{
		tpick_cast_spells (402)
		tpick_cast_spells (404)
		tpick_prep_spell(408, "Disarm")
		fput "cast at ##{current_box.id}"
		while line = get
			if line =~ /Now to isolate the offending mechanism and disable it\.\.\.The.*vibrates slightly but nothing else happens\.|You begin to probe the.*for unusual mechanisms\.\.\.The.*vibrates slightly but nothing else happens\./
				echo "Couldn't disarm trap. Tryin again."
				break
			elsif line =~ /Now to isolate the offending mechanism and disable it\.\.\.Your heart skips a beat as you hear a small sizzle from the.*keyhole\..*You begin to jump back\, but not in time as the entire.*explodes in a deafening\, fiery detonation\!/
				echo "The trap was set off! Script is now exiting."
				exit
			elsif line =~ /Now to isolate the offending mechanism and disable it\.\.\.The.*pulses once with a deep crimson light\!/
				box_is_disarmed = true
				echo "Box is disarmed."
				break
			end
		end
		break if box_is_disarmed
	}
	pop_open_box.call
}

fill_up_locksmith_container = proc{
	move 'out' if checkpaths 'out'
	start_script 'go2', [ 'bank', '--disable-confirm' ]
	wait_while{ running?('go2') }
	fput "unhide" if hidden?
	fput "depo all"
	fput "withdraw 1000"
	start_script 'go2', [ Room[Room.current.find_nearest_by_tag('locksmith')], '--disable-confirm' ]
	wait_while{ running?('go2') }
	waitrt?
	fput "order"
	while line = get
		if line =~ /\d+.*\s{2}(\d+).*locksmith\'s/
			order_number = $1
		elsif line =~ /(\d+).*locksmith\'s/
			order_number = $1
		end
		break if line =~ /You can APPRAISE/
	end
	stow_both.call
	wait_until { checkleft.nil? }
	wait_until { checkright.nil? }
	until checkright
		waitrt?
		fput "remove ##{locksmiths_container.id}"
		sleep 0.2
	end
	buy_locksmith_pouch.call
	if putty_remaining < 50 || cotton_remaining < 50
		buy_locksmith_pouch.call
	end
	fput "wear ##{locksmiths_container.id}"	
}

buy_locksmith_pouch = proc{
	fput "order #{order_number}"
	fput "buy"
	wait_until { checkleft }
	fput "bundle"
	trash_container = GameObj.loot.find { |trash| trash.name =~ trash_container }
	current_box = GameObj.left_hand
	if trash_container == nil
		tpick_drop_box(current_box)
	else
		fput "put ##{GameObj.left_hand.id} in #{trash_container}"
		sleep 0.2
		tpick_drop_box(current_box) if checkleft
	end
}

check_locksmiths_container = proc{
	action = proc { |server_string|
		if server_string =~ /lump of squishy white putty with about (\d+) pinch|(\d+) little ball|(\d+) vials? of liquid|you see a pinch of squishy white putty/
			if server_string =~ /you see a lump of squishy white putty with about (\d+) pinch/
				putty_remaining = $1.to_i
			elsif server_string =~ /you see a pinch of squishy white putty/
				putty_remaining = 1
			else 
				putty_remaining = 0
			end
			if server_string =~ /(\d+) little ball/
				cotton_remaining = $1.to_i
			else
				cotton_remaining = 0
			end
			if server_string =~ /(\d+) vials? of liquid/
				vials_remaining = $1.to_i
			else
				vials_remaining = 0
			end
			DownstreamHook.remove("#{script.name}_check_locksmiths_container")
			nil
		elsif server_string =~ / and /
			(putty_remaining = 0) unless (putty_remaining)
			(cotton_remaining = 0) unless (cotton_remaining)
			(vials_remaining = 0) unless (vials_remaining)
			DownstreamHook.remove("#{script.name}_check_locksmiths_container")
			server_string
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_check_locksmiths_container", action)
		silence_me
		if running? "sorter"
			kill_script "sorter"
			wait_until { !running? "sorter" }
			start_sorter = true
		end
		fput "look in ##{locksmiths_container.id}"
		silence_me
}

do_relock_boxes = proc{
	waitrt?
	tpick_get_box(current_box) if solo_or_other == "ground"
	fput "get ##{$vaalin_lockpick_id}"
	fput "close ##{current_box.id}"
	fput "lm relock ##{current_box.id}"
	tpick_drop_box(current_box) if solo_or_other == "ground"
	fput "put ##{$vaalin_lockpick_id} in ##{lockpick_container.id}"
}

cast_407 = proc{
	if current_box.name =~ /enruned|mithril/i || box_is_enruned_or_mithril || UserVars.tpick["always_use_407"] =~ /no/i
		echo "Can't open this plated box because it is mithril or enruned or because your settings are set to not use 407 to open boxes."
		if solo_or_other == "solo"
			where_to_stow_box.call
			stow_both.call
			sleep 0.1
		elsif solo_or_other == "other"
			tpick_say_cant
			open_others.call
		elsif solo_or_other == "ground"
			tpick_drop_box(current_box)
			cant_open_plated_box_count += 1
			box_opened = nil
		elsif solo_or_other == "worker"
			ask_worker.call
		end
	else
		if checkmana < 10
			echo "Waiting for mana."
			wait_until { checkmana >= 10 }
		end
		tpick_cast_spells (403) unless UserVars.tpick["always_use_403"] == "never"
		tpick_prep_spell(407, "Unlock")
		result = dothistimeout "cast ##{current_box.id}", 4, /vibrates slightly but nothing else happens.|(suddenly flies open.|is already open.)/i
		if result =~ /(suddenly flies open.|is already open.)/i
			if solo_or_other == "solo"
				open_solo.call
			elsif solo_or_other == "other"
				open_others.call
			elsif solo_or_other == "ground"
				tpick_drop_box(current_box)
			elsif solo_or_other == "worker"
				nil
			end
		elsif result =~ /vibrates slightly but nothing else happens./i || result.nil?
			cast_407.call
		end
	end
}

wedge_lock = proc{
	waitrt?
	tpick_get_box(current_box) if solo_or_other == "ground" && checkright == nil
	3.times{
		waitrt?
		unless GameObj.right_hand.name =~ /wedge/ || GameObj.left_hand.name =~ /wedge/
			fput "get my wedge"
			sleep 0.2
		end
	}
	if GameObj.right_hand.name !~ /wedge/ && GameObj.left_hand.name !~ /wedge/
		if UserVars.tpick["always_use_407"] =~ /no/i or !Spell[407].known?
			if solo_or_other == "other"
				tpick_say_cant
				open_others.call
			elsif solo_or_other == "ground"
				echo "Couldn't open this box."
				box_opened = nil
			elsif solo_or_other == "solo"
				echo "Couldn't open this box."
				where_to_stow_box.call
				stow_both.call
				sleep 0.1
			elsif solo_or_other == "worker"
				echo "Couldn't open this box."
				ask_worker.call
			end
		else
			echo "Couldn't find any wedges, going to try popping this box."
			cast_407.call
		end
	else
		result = dothistimeout "lmaster wedge ##{current_box.id}", 3, /What do you expect to wedge it with|(suddenly splits away from the casing|Why bother)|Roundtime/i
		if result =~ /What do you expect to wedge it with/i
			stow_wedge.call
			wedge_lock.call
		elsif result =~ /(suddenly splits away from the casing|Why bother)/i
			stow_wedge.call
			open_solo.call if solo_or_other == "solo"
			open_others.call if solo_or_other == "other"
			tpick_drop_box(current_box) if solo_or_other == "ground"
		elsif result =~ /Roundtime/i || result.nil?
			wedge_lock.call
		end
	end
}

calibrate = proc{
	echo "Calibrating calipers."
	3.times{
		waitrt?
		unless GameObj.right_hand.name =~ /calipers/ || GameObj.left_hand.name =~ /calipers/
			fput "get my calipers"
			sleep 0.2
		end
	}
	if GameObj.right_hand.name !~ /calipers/ && GameObj.left_hand.name !~ /calipers/
		echo "Couldn't find your calipers."
		exit
	end
	result = dothistimeout "lmas calibrate my calipers", 4, /You\'re good\, but you\'re not that good\.|You should leave them alone.|Roundtime/i
	if result =~ /You\'re good\, but you\'re not that good\.|You should leave them alone./i
		stow_calipers.call
	elsif result =~ /Roundtime/i
		waitrt?
		calibrate.call if can_use_calipers
	elsif result.nil?
		calibrate.call
	end
}

check_for_lockpicks_etc = proc {
	action = proc { |server_string|
		if server_string =~ /\s{2}.*(an?|the|some) |\s{6}.*(an?|the|some) |^You are currently wearing and carrying\:/
			if server_string =~ /\<a exist\=\"(\d+)" noun\=\".*\"\>(.*)\<\/a\>/
				temp_id = $1
				temp_name = $2
				$copper_lockpick_id = temp_id if temp_name =~ /^#{UserVars.tpick["copper"]}$/
				$steel_lockpick_id = temp_id if temp_name =~ /^#{UserVars.tpick["steel"]}$/
				$gold_lockpick_id = temp_id if temp_name =~ /^#{UserVars.tpick["gold"]}$/
				$silver_lockpick_id = temp_id if temp_name =~ /^#{UserVars.tpick["silver"]}$/
				$mithril_lockpick_id = temp_id if temp_name =~ /^#{UserVars.tpick["mithril"]}$/
				$ora_lockpick_id = temp_id if temp_name =~ /^#{UserVars.tpick["ora"]}$/
				$glaes_lockpick_id = temp_id if temp_name =~ /^#{UserVars.tpick["glaes"]}$/
				$laje_lockpick_id = temp_id if temp_name =~ /^#{UserVars.tpick["laje"]}$/
				$vultite_lockpick_id = temp_id if temp_name =~ /^#{UserVars.tpick["vultite"]}$/
				$rolaren_lockpick_id = temp_id if temp_name =~ /^#{UserVars.tpick["rolaren"]}$/
				$veniom_lockpick_id = temp_id if temp_name =~ /^#{UserVars.tpick["veniom"]}$/
				$invar_lockpick_id = temp_id if temp_name =~ /^#{UserVars.tpick["invar"]}$/
				$alum_lockpick_id = temp_id if temp_name =~ /^#{UserVars.tpick["alum"]}$/
				$golvern_lockpick_id = temp_id if temp_name =~ /^#{UserVars.tpick["golvern"]}$/
				$kelyn_lockpick_id = temp_id if temp_name =~ /^#{UserVars.tpick["kelyn"]}$/
				$vaalin_lockpick_id = temp_id if temp_name =~ /^#{UserVars.tpick["vaalin"]}$/
				$scale_trap_weapon_id = temp_id if temp_name =~ /^#{UserVars.tpick["scale_trap_weapon"]}$/
			end
			nil
		elsif server_string =~ /^\(\d+ items? displayed\.\)/
			DownstreamHook.remove("#{script.name}_check_for_lockpicks_etc")
			$tpick_boxes_checked = true
			nil
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_check_for_lockpicks_etc", action)
		silence_me
		fput "inv full"
		silence_me
}

check_for_boxes = proc {
	action = proc { |server_string|
		if server_string =~ /\s{6}.*(an?|the|some) |\s{2}.*(an?|the|some) |^You are currently wearing and carrying\:/
			if (server_string =~ /(\s{6}.*(an?|the|some)|\s{2}.*(an?|the|some)).*exist="(\d+)".*(plinite)/) && (open_plinites)
				$tpick_list_of_box_ids.push($4)
			elsif (server_string =~ /(\s{6}.*(an?|the|some)|\s{2}.*(an?|the|some)).*exist="(\d+)" noun="(strongbox|box|chest|trunk|coffer)".*/) && (open_plinites == nil)
				$tpick_list_of_box_ids.push($4)
			end
			nil
		elsif server_string =~ /^\(\d+ items? displayed\.\)/
			DownstreamHook.remove("#{script.name}_check_for_boxes")
			$tpick_boxes_checked = true
			nil
		elsif server_string =~ /You glance down to see.*mithril|enruned.*/
			check_hands_status = "mithril or enruned"
			DownstreamHook.remove("#{script.name}_check_for_boxes")
			nil
		elsif server_string =~ /You glance down.*left hand.*/
			check_hands_status = "good"
			DownstreamHook.remove("#{script.name}_check_for_boxes")
			nil
		elsif server_string =~ /You glance down at your empty hands\./
			check_hands_status = "empty"
			DownstreamHook.remove("#{script.name}_check_for_boxes")
			nil
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_check_for_boxes", action)
		silence_me
		fput "#{check_for_command}"
		silence_me
}

cast_205 = proc{
	if checkmana < 5
		echo "Waiting for mana."
	end
	Spell[205].cast
}

stuff_to_do = proc{
	if (UserVars.tpick["rest_percent"].to_i <= percentmind) && (UserVars.tpick["rest_percent"].length > 0)
		echo "Resting until mind reaches #{UserVars.tpick["pick_percent"]}%."
		wait_until { UserVars.tpick["pick_percent"].to_i >= percentmind }
	end
}

start_values_nilled = proc{
	scale_trap_found = nil
	current_trap_type = nil
	second_trap_check = nil
	found_true_lock_difficulty = nil
}

start_solo = proc{
	total_boxes_count.call
	$tpick_list_of_box_ids.each{ |box|
		tpick_stop_403_404
		fput "get ##{box}"
		start_time = Time.now
		start_values_nilled.call
		stuff_to_do.call
		number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
		if (gnomish_bracers) && (bracers_tier == "2")
			gnomish_bracers_trap_check.call
		else
			manually_disarm_trap.call
		end
	}
	check_disk.call
}

start_worker = proc{
	stow_both.call
	stuff_to_do.call
	current_box = nil
	waitrt?
	if worker.nil?
		echo "Get yourself to a worker who assigns you box jobs."
		exit
	end
	fput "ask ##{worker.id} for job"
	while line = get
		if line =~ /says\, \"You should finish the job you\'re working on first\.  If you\'re done\, ask me to CHECK it for you\.\"/
			next_task = nil
			break
		elsif line =~ /says\, \"Ah\, here we are\.  The client is offering a tip of (\d+) silvers? and mentioned it being from .* \(level (\d+)\)\./
			offered_tip_amount = $1.to_i
			critter_level = $2.to_i
			next_task = nil
			break
		elsif line =~ /says\, \"We don't have any jobs for you at the moment\./ || line =~ /says\, \"You haven\'t quite reflected on your past failure\.|says\, \"You\'ve done enough boxes for now\./
			next_task = "wait"
			break
		end
	end
	if next_task == "wait"
		echo "No boxes available at the moment, waiting 15 seconds and trying again."
		sleep 15
		start_worker.call
	else
		start_worker2.call
	end
}
	
start_worker2 = proc{
	if offered_tip_amount <= minimum_tip_wanted
		echo "Minimum tip wanted not met, turning in box."
		ask_worker.call
		ask_worker.call
		start_worker.call
	elsif critter_level > max_critter_level
		echo "Critter level too high, turning in box."
		ask_worker.call
		ask_worker.call
		start_worker.call
	else
		tpick_stop_403_404
		start_values_nilled.call
		number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
		if (gnomish_bracers) && (bracers_tier == "2")
			gnomish_bracers_trap_check.call
		else
			manually_disarm_trap.call
		end
		ask_worker.call
		start_worker.call
	end
}

start_others = proc{
	waitfor "has accepted your offer" if checkright != nil
	waitrt?
	fput "accept"
	while line = get
		if line =~ /^You accept ([a-zA-Z]+)\'s offer and are now holding.*\.$/i || line =~ /^([a-zA-Z]+) offers you (.*) (box|strongbox|coffer|chest|trunk).  Click ACCEPT to accept the offer or DECLINE to decline it.  The offer will expire in 30 seconds\.$/
			person = $1
			fput "accept" if line =~ /^([a-zA-Z]+) offers you (.*) (box|strongbox|coffer|chest|trunk).  Click ACCEPT to accept the offer or DECLINE to decline it.  The offer will expire in 30 seconds\.$/
			start_time = Time.now
			tpick_stop_403_404
			start_values_nilled.call
			number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
			if (gnomish_bracers) && (bracers_tier == "2")
				gnomish_bracers_trap_check.call
			else
				manually_disarm_trap.call
			end
			break
		end
	end
}

total_boxes_count = proc{
	total_boxes_number = 0
	if solo_or_other == "ground"
		GameObj.loot.each { |item|
			(total_boxes_number += 1) if (item.type == "box")
		}
	elsif solo_or_other == "solo"
		total_boxes_number = $tpick_list_of_box_ids.length
		unless disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
			echo "Waiting 5 seconds for disk"
			50.times { break if GameObj.loot.any? { |obj| obj.name =~ /#{Char.name} disk|coffin/ }; sleep 0.1 }
				disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
			end
		(echo "No disk found.") if (disk == nil)
		if (disk) && (disk.contents.nil?)
			dothistimeout "look in ##{disk.id}", 3, /In the|There is nothing in/
		end
		disk.contents.each{|item|
			if item.type =~ /box/i
				total_boxes_number += 1
			end
		}
	end
	total_boxes_picked_math.call
}

bash_the_box_open = proc{
	echo "Bashing open box."
	waitrt?
	result = dothistimeout "open ##{current_box.id}", 3, /That is already open\.|You open|It appears to be locked\./i
	if result =~ /That is already open\.|You open/
		box_counts_for_math = nil
		box_was_not_locked = true
	elsif result =~ /It appears to be locked\./ 
		fput "get my #{UserVars.tpick["bashing_weapon"]}"
		until current_box.status == "gone"
			waitrt?
			fput "bash ##{current_box.id}"
			waitrt?
			sleep 0.2
		end
	elsif result.nil?
		bash_the_box_open.call
	end
	
}

start_ground = proc{
	total_boxes_count.call
	GameObj.loot.each{|box|
		if box.type =~ /box/
			box_opened = true
			current_box = box
			tpick_stop_403_404
			if (UserVars.tpick["rest_percent"].to_i <= percentmind) && (UserVars.tpick["rest_percent"].length > 0)
				echo "Resting until mind reaches #{UserVars.tpick["pick_percent"]}%."
				wait_until { UserVars.tpick["pick_percent"].to_i >= percentmind }
			end
			waitrt?
			box_was_not_locked = nil
			start_time = Time.now
			start_values_nilled.call
			number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
			if popping
				current_box = current_box.id
				pop_boxes_begin.call
			elsif bash_open_boxes
				if disarm_only
					if (gnomish_bracers) && (bracers_tier == "2")
						gnomish_bracers_trap_check.call
					else
						manually_disarm_trap.call
					end
				else
					bash_the_box_open.call
				end
			else
				if (gnomish_bracers) && (bracers_tier == "2")
					gnomish_bracers_trap_check.call
				else
					manually_disarm_trap.call
				end
			end
			update_math_information = true
			total_boxes_picked_math.call
			if ground_loot
				if (bash_open_boxes) && (box_was_not_locked == nil)
					GameObj.loot.each{ |item|
						waitrt?
						if (item.name !~ /urglaes fang|doomstone|disk|coffin|stairs/) && (item.type != "box")
							waitrt?
							fput "get ##{item.id}"
							if item.name =~ /coins/
								while line = get
									if line =~ /You gather the remaining (\d+) coins?/
										if $1.to_i < 625
											sleep 0.1
										else
											while line = get
												if line =~ /Roundtime\: (\d+) sec/
													sleep ($1.to_i + 1)
													break
												end
											end									
										end
										waitrt?
										break
									end
								end
							end
						end
						waitrt?
						if item.name !~ /coins/i && UserVars.tpick["log"] == "yes"
							record_item_data.call
						end
						if (item.name !~ /urglaes fang|doomstone|disk|coffin|stairs|coins/) && (item.type != "box")
							if UserVars.tpick["auto_bundle_vials"] == "yes" && item.name =~ /vial/ && (GameObj.right_hand.name =~ /vial/ || GameObj.left_hand.name =~ /vial/)
								check_locksmiths_container.call
								wait_until { vials_remaining }
								start_script "sorter" if start_sorter
								if vials_remaining < 10
									if GameObj.right_hand.name =~ /vial/
										current_vial = GameObj.right_hand.id
									elsif GameObj.left_hand.name =~ /vial/
										current_vial = GameObj.left_hand.id
									end
									fput "stow ##{current_vial}"
									sleep 0.2
									stow_both.call
									wait_until { checkleft == nil }
									wait_until { checkright == nil }
									fput "remove ##{locksmiths_container.id}"
									wait_until { checkright != nil }
									fput "get ##{current_vial}"
									wait_until { checkleft != nil }
									fput "bundle"
									fput "wear ##{locksmiths_container.id}"
									wait_until { checkright == nil }			
								end
							else
								if (item.type =~ /gem/) && (gem_container)
									fput "put #{item} in ##{gem_container.id}"
								else
									fput "stow #{item}"
								end
							end
						end
						waitrt?
					}
				elsif (box_opened) || (box_was_not_locked)
					waitrt?
					(tpick_cast_spells (506)) if (use_spell_506)
					total_boxes_picked += 1
					fput "open ##{current_box.id}" unless popping
					(dothistimeout "look in ##{box.id}", 10, /In .*? you see|In the .*\:|There is nothing in/i) if box.contents.nil?
					box.contents.each{ |item|
						waitrt?
						if (item.name !~ /urglaes fang/) && (item.name !~ /doomstone/)
							waitrt?
							fput "get #{item} from ##{current_box.id}"
							if item.name =~ /coins/
								while line = get
									if line =~ /You gather the remaining (\d+) coins?/
										if $1.to_i < 625
											sleep 0.1
										else
											while line = get
												if line =~ /Roundtime\: (\d+) sec/
													sleep ($1.to_i + 1)
													break
												end
											end									
										end
										waitrt?
										break
									end
								end
							end
						end
						waitrt?
						if item.name !~ /coins/i && UserVars.tpick["log"] == "yes"
							record_item_data.call
						end
						if item.name !~ /coins/i && item.name !~ /urglaes fang/ && item.name !~ /doomstone/
							if UserVars.tpick["auto_bundle_vials"] == "yes" && item.name =~ /vial/ && (GameObj.right_hand.name =~ /vial/ || GameObj.left_hand.name =~ /vial/)
								check_locksmiths_container.call
								wait_until { vials_remaining }
								start_script "sorter" if start_sorter
								if vials_remaining < 10
									if GameObj.right_hand.name =~ /vial/
										current_vial = GameObj.right_hand.id
									elsif GameObj.left_hand.name =~ /vial/
										current_vial = GameObj.left_hand.id
									end
									fput "stow ##{current_vial}"
									sleep 0.2
									stow_both.call
									wait_until { checkleft == nil }
									wait_until { checkright == nil }
									fput "remove ##{locksmiths_container.id}"
									wait_until { checkright != nil }
									fput "get ##{current_vial}"
									wait_until { checkleft != nil }
									fput "bundle"
									fput "wear ##{locksmiths_container.id}"
									wait_until { checkright == nil }			
								end
							else
								if (item.type =~ /gem/) && (gem_container)
									fput "put #{item} in ##{gem_container.id}"
								else
									fput "stow #{item}"
								end
							end
						end
						waitrt?
					}
					if relock_boxes
						do_relock_boxes.call
					end
					garbage_check.call
				end
			else
				if popping
					nil
				else
					fput "open ##{current_box.id}" if (box_opened) && (disarm_only == nil)
					fput "drop ##{current_box.id}" if GameObj.right_hand.id == current_box.id
				end
			end
			stow_both.call
		end
	}
	echo "All done!"
	echo "Couldn't open #{cant_open_plated_box_count} box(es), which are still on the ground." if cant_open_plated_box_count > 0
	exit
}

check_disk = proc{
	stow_in_disk = true
	unless disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
		echo "Waiting 5 seconds for disk"
		50.times { break if GameObj.loot.any? { |obj| obj.name =~ /#{Char.name} disk|coffin/ }; sleep 0.1 }
			disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk|coffin/ }
		end
	if disk == nil
		echo "No disk found."
		exit
	end
	if disk and disk.contents.nil?
		dothistimeout "look in ##{disk.id}", 3, /In the|There is nothing in/
	end
	disk.contents.each{|item|
		if item.type =~ /box/i
			waitrt?
			if popping
				current_box = item.id
				pop_boxes_begin.call
			else
				fput "get ##{item.id}"
				start_time = Time.now
				start_values_nilled.call
				number_of_manual_trap_checks_remaining = UserVars.tpick["number_of_times_to_check_for_traps"].to_i
				if (gnomish_bracers) && (bracers_tier == "2")
					gnomish_bracers_trap_check.call
				else
					manually_disarm_trap.call
				end
			end
		end
	}
}

manually_disarm_trap = proc{
	waitrt?
	if solo_or_other == "worker" && current_box.nil?
		dothistimeout "look on ##{table.id}", 3, /^On the/
		table.contents.each{ |item|
			if item.name =~ /#{checkname}/
				current_box = item
				break
			end
		}
		wait_until { current_box }
		sleep 1
	end
	if current_box.name =~ /plinite/
		detect_plinite.call
	else
		if second_trap_check
			echo "Attempting to disarm trap."
		else
			echo "Checking for traps."
			need_403 = nil
			need_404 = nil
		end
		if (current_trap_type == "sphere") || (current_trap_type == "Sphere trap found, need to use lockpick to disarm.")
			3.times{
				waitrt?
				unless GameObj.right_hand.id == $vaalin_lockpick_id || GameObj.left_hand.id == $vaalin_lockpick_id
					fput "get ##{$vaalin_lockpick_id}"
					sleep 0.2
				end
			}
			if GameObj.right_hand.id != $vaalin_lockpick_id && GameObj.left_hand.id != $vaalin_lockpick_id
				echo "Couldn't find your #{UserVars.tpick["vaalin"]}."
				exit
			end
		end
		waitrt?
		(tpick_cast_spells (402)) if (use_spell_402)
		(tpick_cast_spells (404)) if (use_spell_404) || (need_404)
		(tpick_cast_spells (506)) if (use_spell_506)
		(tpick_cast_spells (613)) if (use_spell_613)
		(tpick_cast_spells (1006)) if (use_spell_1006)
		trap_difficulty = nil
		trap_cant_be_disarmed = nil
		if solo_or_other != "ground" && solo_or_other != "worker"
			wait_until { GameObj.right_hand.id}
			current_box = GameObj.right_hand
		end
		waitrt?
		fput "disarm ##{current_box.id}"
		while line = get
			if line =~ /\(.*\-(\d+)\)\./
				trap_difficulty = $1.to_i
				disarm_skill_plus_lore = (disarm_skill + disarm_lore)
				total_trap_skill = (disarm_skill + disarm_lore + UserVars.tpick["trap_roll"].to_i)
				if second_trap_check == nil
					echo "Trap difficulty is: #{trap_difficulty}"
					echo "Your disarm skill is: #{disarm_skill}"
					echo "Your total disarm skill with lore is: #{disarm_skill_plus_lore}"
					echo "Highest trap you are willing to try is: #{total_trap_skill}"
				end
				if trap_difficulty > total_trap_skill
					trap_cant_be_disarmed = true
				elsif trap_difficulty > disarm_skill && Spell[404].known?
					if second_trap_check == nil
						echo "This trap looks tough, going to use Disarm Enhancement (404)."
					end
					need_404 = "yes"
				elsif trap_difficulty > disarm_skill && !Spell[404].known?
					trap_cant_be_disarmed = true
				end
	#####Is box enruned or mithril?
			elsif line =~ /You carefully begin to examine an? (.*) for traps\.\.\./
				box_is_enruned_or_mithril = nil
				box_is_enruned_or_mithril = true if $1 =~ /enruned|mithril/
	#####Failed to disarm box
			elsif line =~ /Having discovered a trap on the.*(box|strongbox|chest|trunk|coffer) you begin to carefully attempt to disarm it\.\.\./
				current_trap_type = "Couldn't disarm trap, trying again."
	#####Scarab information#####
			#Manual detection
			elsif line =~ /Peering closely into the lock\, you spy.*scarab wedged into the lock mechanism\./
				CharSettings['scarab'] += 1
				CharSettings['total_trap_count'] += 1
				current_trap_type = "scarab"
			#Successful manual disarm
			elsif line =~ /You carefully nudge the scarab free of its prison without disturbing the lock too much\.\s+The scarab falls from the lock and onto the ground in front of you\./
				current_trap_type = "Scarab trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /The lock appears to be free of all obstructions\./
				current_trap_type = "Scarab trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /Looking closely at the lock\, you spy.*scarab wedged into the lock mechanism\.\s+The scarab is surrounded by crimson glow\./
				current_trap_type = "Scarab trap has already been disarmed with 408."
				break
	#####Needle information#####
			#Manual detection
			elsif line =~ /Hmmm\, you can see what appears to be a tiny hole next to the lock plate which doesn\'t seem to belong there\.\s+Looking closer you see a gleaming sliver of metal recessed in the hole\./
				current_trap_type = "needle"
				CharSettings['needle'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Using a bit of putty from your.*\, you manage to block the tiny hole in the lock plate\.|Using a pair of metal grips\, you carefully remove .* from .* and cover the tip with a bit of putty\./
				current_trap_type = "Needle trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /You see a tiny hole next to the lock plate which has been completely plugged\.|You can see what appears to be a tiny hole next to the lock plate which doesn\'t seem to belong there\.  However\, nothing about it seems to indicate cause for alarm\.|You spot a shiny metal needle sticking out of a small hole next to the lockplate with some sort of dark paste on it\./
				current_trap_type = "Needle trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /You can see what appears to be a tiny hole next to the lock plate which doesn\'t belong there\.\s+An occasional glint of red winks at you from within the hole\./
				current_trap_type = "Needle trap has already been disarmed with 408."
				break
	#####Jaws information#####
			#Manual detection
			elsif line =~ /You notice a discolored oval ring around the outside of the .*(box|strongbox|chest|trunk|coffer) which makes you suspicious\.\s+Your suspicions are confirmed when you look inside the keyhole and notice the spring\-loaded jaws pressed flush against the .*(box|strongbox|chest|trunk|coffer) walls\./
				current_trap_type = "jaws"
				CharSettings['jaws'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Using the pair of metal grips\, you manage to pull out the two pins that hold the upper and lower jaw pieces together\.\s+As the pins are removed\, the jaws suddenly close and warp under the tremendous strain applied by their arming mechanism\.|Using the pair of metal grips\, you manage to pull out the two pins that hold the upper and lower jaw pieces together\.|Using your metal grips\, you carefully remove a pair of small steel jaws from the .*(box|strongbox|chest|trunk|coffer) before piecing the apparatus back together\./
				current_trap_type = "Jaws trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /You notice a discolored oval ring around the outside of the .*(box|strongbox|chest|trunk|coffer) which makes you suspicious\.\s+Your suspicions are confirmed when you look inside the keyhole and notice the spring\-loaded jaws pressed flush against the.*walls\, but the pins that hold the jaws together have been pushed out\.|You notice a discolored oval ring around the outside of the .*\, but further examination gives the impression that some vital part of whatever trap was here has been removed\./
				current_trap_type = "Jaws trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /You see a pair of metal jaws clamped tightly before the lockplate on the.*(box|strongbox|chest|trunk|coffer)\./
				current_trap_type = "Jaws trap has already been disarmed with 408. Can't pick it."
				break
			#Trap has already been set off
			elsif line =~ /You see a pair of bloody jaws clamped tightly before the lockplate on the/
				current_trap_type = "Jaws trap has already been set off."
				break
	#####Sphere information#####
			#Manual detection
			elsif line =~ /Examining the .*(box|strongbox|chest|trunk|coffer)\, you locate.*sphere held in a metal bracket towards the back of the lock mechanism\..*It appears that were the tumblers to be activated\, the gem would be caught amongst them\./
				current_trap_type = "sphere"
				CharSettings['sphere'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /With utmost care\, you slip your.* into the lock and gently nudge the.*Another moment of prodding\, and you are able to poke the gem free of its metal housing\, whereupon it falls down into the lock mechanism and out of sight\.|With utmost care\, you slip your.* into the lock and gently nudge the.*Tilting the .*(box|strongbox|chest|trunk|coffer) forward\, you knock the gem free of its metal housing and poke it out through the back of the lock\, allowing it to gently roll down the inside of the .*(box|strongbox|chest|trunk|coffer)\'s front wall\./
				current_trap_type = "Sphere trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /A thorough search of the area inside the tumblers reveals what appears to be a metal bracket of some sort\, although it seems to be empty now\./
				current_trap_type = "Sphere trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /The sphere is surrounded by a crimson glow\./
				current_trap_type = "Sphere trap has already been disarmed with 408."
				break
			#Need pick in hand messaging
			elsif line =~ /No matter how you try\, your fingers are just too big to get back there to the gem\.\s+You\'ll need some sort of thin\, rigid implement like a lockpick\./
				current_trap_type = "Sphere trap found, need to use lockpick to disarm."
			#Setting off trap manually
			elsif line =~ /Suddenly\, you hear a sound like shattered crystal and .* light flashes from the lock mechanism\!/
				current_trap_type = "Sphere trap has been set off."
				echo "Sphere trap has been set off! Exiting."
				exit
			#Trap has already been set off
			elsif line =~ /A thorough and careful search of the lock mechanism indicates that the entire .* is MANGLED\. It\'s probably not trapped anymore\./
				current_trap_type = "Sphere trap has already been set off."
				break
	#####Crystal information#####
			#Manual detection
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy.*crystal which seems imbedded in the locking mechanism\.\s+It looks as if opening the lock without the exact key could shatter it\./
				current_trap_type = "crystal"
				CharSettings['crystal'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /With a little ingenuity you manage to grind down parts of the lock mechanism with your metal file\, so it won\'t come in contact with the crystal when you try to open it\./
				current_trap_type = "Crystal trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy.*crystal which seems imbedded in the locking mechanism\.\s+It looks as if opening the lock without the exact key could shatter it\, but parts of the mechanism have been ground away to avoid unwanted contact with the crystal\./
				current_trap_type = "Crystal trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /You can see.*crystal imbedded in the locking mechanism\, with a slight reddish glow about it\./
				current_trap_type = "Crystal trap has already been disarmed with 408."
				break
	#####Scales information#####
			#Manual detection
			elsif line =~ /At first glance\, the.*(box|strongbox|chest|trunk|coffer) appears to be covered with hundreds of tiny metal scales\.\s+Closer examination reveals the \"scales\" to be razor sharp at the edges and possessing of a downward\-facing needlelike tip\.\s+However\, you should be able to avoid cutting yourself if you are careful\.|Despite heavy scrutiny\, you can see no way to pry off any of the scales\, nor any particular reason to\.\s+With a modicum of caution\, they should present no danger\.\s+Nothing else about the.*(box|strongbox|chest|trunk|coffer) suggests that it is trapped\./
				current_trap_type = "scales"
				CharSettings['scales'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /You gently slide your.*into the space under the lid and slice through the cord\.\s+That oughta do it\./
				current_trap_type = "Scales trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Peering in through the crack between the lid and the casing\, you see what appears to be a thin cord dangling from the case\.\s+It looks to have been sliced through\./
				current_trap_type = "Scales trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /A crimson glow seeps between the lid and the casing of the .*(box|strongbox|chest|trunk|coffer)\./
				current_trap_type = "Scales trap has already been disarmed with 408."
				break
			#Need dagger in hand messaging
			elsif line =~ /You figure that if you had a dagger\, you could probably cut the cord\./
				current_trap_type = "Scales trap found, need to use dagger to disarm."
				break
	#####Sulphur information#####
			#Manual detection
			elsif line =~ /Feeling around the inside of the lock\, you notice that the casing is coated with a rough\, grainy substance\.\s+You lean forward and peer between the walls of the casing\.\s+Examining the lock closely\, you notice a small bladder filled with a strange liquid wedged between the tumblers\.\s+With your face this close to the lock\, you pick up the faintest scent of sulphur\./
				current_trap_type = "sulphur"
				CharSettings['sulphur'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /You carefully use the tip of a small metal file to scrape away the rough\, grainy substance which lines the walls of the casing\.\s+After a few moments\, you feel comfortable with the small section you have cleaned\.\s+You take out a thin needle and carefully slide it between the walls of the casing\, taking great care not to touch them\.\s+As the tip of the needle punctures the small bladder\, a strange clear gel oozes forth from the hole\.\s+The gel gives off a strong odor of sulphur\.\s+As the air hits the gel\, it begins to harden and turn to dust\, blowing away in the wind as if it never existed\./
				current_trap_type = "Sulphur trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Feeling around the inside of the lock\, you notice that the casing is coated with a rough\, grainy substance\.\s+A small section of the casing has been scraped clean of the strange substance\.\s+You lean forward and peer between the walls of the casing\.\s+Examining the lock closely\, you notice a deflated bladder wedged between the tumblers\.\s+There is a small hole in the bladder\, most likely from whatever ruptured it\.\s+The lock emanates a strong scent of sulphur\./
				current_trap_type = "Sulphur trap has already been disarmed."
				break
			#Already disarmed with 408
			#TRAP CANNOT BE DISARMED WITH 408
	#####Cloud information#####
			#Manual detection
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of liquid and a tiny hammer device which seems poised to shatter it if the lock is tampered with\./
				current_trap_type = "cloud"
				CharSettings['cloud'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Using the metal grips from your.*\, you manage to reach in and grasp the post of the metal hammer\, and bend the weak metal out of striking range of the vial\.|Having rendered the hammer harmless\, you carefully remove a green\-tinted vial filled with thick acrid smoke from the .*(box|strongbox|chest|trunk|coffer)\./
				current_trap_type = "Cloud trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy a tiny hammer device which has been bent back slightly\.|Looking closely into the keyhole of the lock\, you spy a small vial of liquid and a tiny hammer device which has been bent from striking range of the vial\./
				current_trap_type = "Cloud trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of liquid and a tiny hammer device which has a red glow about it\./
				current_trap_type = "Cloud trap has already been disarmed with 408."
				break
	#####Acid vial information#####
			#Manual detection
			elsif line =~ /Peering closely into the lock\, you spy a tiny vial placed just past the tumblers of the lock mechanism\.\s+It would appear that any tampering with the lock mechanism would cause the tumblers to crush the vial and release whatever substance is inside\./
				current_trap_type = "acid vial"
				CharSettings['acid_vial'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /You carefully push a small ball of cotton into the lock mechanism\, surrounding and protecting the small vial from anything that may shatter it\.|Using a pair of metal grips\, you carefully remove the padded clear glass vial from the .*(box|strongbox|chest|trunk|coffer)\./
				current_trap_type = "Acid vial trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Peering closely into the lock\, you spy a tiny vial placed just past the tumblers of the lock mechanism\.\s+A small ball of cotton has been pushed up against the vial\, protecting it from anything that may shatter it\.|Looking closely at the lock\, you spy a small metal housing set just inside the lock mechanism\, but it appears empty\.|Looking closely into the keyhole of the lock\, you spy a small metal housing\, which appears to be empty\./
				current_trap_type = "Acid vial trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /You notice what appears to be a tiny vial placed just past the tumblers of the lock mechanism\.\s+A crimson glow surrounds the vial\.|Looking closely at the lock\, you spy a tiny vial set just inside the lock mechanism\.\s+The vial is surrounded by crimson glow\./
				current_trap_type = "Acid vial trap has already been disarmed with 408."
				break
			#Setting off trap manually
			elsif line =~ /You peer inside the lock and see that the tumblers have all been fused into a lump of useless metal/
				current_trap_type = "Acid vial trap has been set off."
				break
			#Trap has already been set off
			elsif line =~ /You peer inside the lock and see that the tumblers have been fused into a lump of useless metal./
				current_trap_type = "Acid vial trap has already been set off."
				break
	#####Springs information#####
			#Manual detection
			elsif line =~ /After carefully examining the lock\, you move on to the hinges of the .*(box|strongbox|chest|trunk|coffer)\.\s+Just as you were to pass the.*(box|strongbox|chest|trunk|coffer) off as safe\, you notice what appears to be the ends of springs incorporated with the hinges\.\s+Seems rather odd to have.*(box|strongbox|chest|trunk|coffer) designed to spring open when it is unlocked\./
				current_trap_type = "springs"
				CharSettings['springs'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /With a little force applied to the springs\, you manage to pop them inside the.*(box|strongbox|chest|trunk|coffer)\, from within which comes the tinkle of breaking glass\, followed by a strong acrid smell\.|With a little force applied to the springs\, you manage to pop them inside.*(box|strongbox|chest|trunk|coffer)\, where they bounce around for a moment\.\s+You also hear something else rolling around in there\./
				current_trap_type = "Springs trap has been disarmed."
				break
			#Already manually disarmed
			#Same messaging as when no traps found.
			#Already disarmed with 408
			elsif line =~ /You spot a reddish glow about the hinges of the.*(box|strongbox|chest|trunk|coffer)\./
				current_trap_type = "Springs trap has already been disarmed with 408."
				break
	#####Fire vial information#####
			#Manual detection
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy a small vial of fire\-red liquid and a tiny hammer device which seems poised to shatter it if the lock is tampered with\./
				current_trap_type = "fire vial"
				CharSettings['fire_vial'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Using the metal grips from your.*\, you manage to reach in and grasp the post of the metal hammer\, and bend the weak metal out of striking range of the vial\.|Having rendered the hammer harmless\, you carefully remove a thick glass vial filled with murky red liquid from the.*(box|strongbox|chest|trunk|coffer)\./
				current_trap_type = "Fire vial trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Looking closely into the keyhole of the lock\, you spy a tiny hammer device which has been bent back slightly\.|Looking closely into the keyhole of the lock\, you spy a small vial of fire\-red liquid and a tiny hammer device which has been bent from striking range of the vial\./
				current_trap_type = "Fire vial trap has already been disarmed."
				break
			#Already disarmed with 408 NEED MESSAGING
			#elsif line =~ //
			#	current_trap_type = "Fire vial trap has already been disarmed with 408."
			#	break
	#####Spores information#####
			#Manual detection
			elsif line =~ /Peering into the.*(box|strongbox|chest|trunk|coffer)\'s lock\, you see a small tube towards the bottom of the tumbler mechanism\.\s+The tube is capped with a thin membrane\, but it seems likely that the tumblers would tear it off while turning\./
				current_trap_type = "spores"
				CharSettings['spores'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Taking a lump of putty from your.*\, you carefully apply it to the end of the small tube\.\s+That should block whatever it\'s meant to deploy\./
				current_trap_type = "Spores trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Peering into the.*(box|strongbox|chest|trunk|coffer)\'s lock\, you see a small tube towards the bottom of the tumbler mechanism\.\s+It appears as though the tube has been plugged with something\./
				current_trap_type = "Spores trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /You see a thin tube extending from the lock mechanism down into the.*(box|strongbox|chest|trunk|coffer)\.\s+The end of the tube is surrounded by a crimson glow\.|Peering into the.*(box|strongbox|chest|trunk|coffer)\'s lock\, you see a small tube towards the bottom of the tumbler mechanism\.\s+A crimson glow surrounds the mouth of the tube\./
				current_trap_type = "Spores trap has already been disarmed with 408."
				break
			#Trap has already been set off
			elsif line =~ /Peering into the (box|strongbox|chest|trunk|coffer)\'s lock\, you see a small tube towards the bottom of the tumbler mechanism\.\s+It appears as though the tube used to be covered with a thin membrane\, but it has torn mostly away\, and greyish\-green powder covers the area around it\./
				current_trap_type = "Spores trap has already been set off."
				break
	#####Plate information#####
			#Manual detection
			elsif line =~ /There appears to be a plate over the lock\, sealing it and preventing any access to the tumblers\.|Gonna chew through it/
				current_trap_type = "plate"
				CharSettings['plate'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /You carefully pour the contents of.*onto the .*(box|strongbox|chest|trunk|coffer) where you think the keyhole ought to be\.\s+.*\, the metal plate covering the lock begins to melt away\./
				current_trap_type = "Plate trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /You see a metal plate covering the lock plate\, but it appears to have been melted through\, granting sufficient access to the lock to attempt picking it./
				current_trap_type = "Plate trap has already been disarmed."
				break
			#Already disarmed with 408
			#Trap can't be disarmed with 408
	#####Glyph information#####
			#Manual detection
			elsif line =~ /You notice some spiderweb\-like scratches on the lock plate which seem\, after some bit of scrutiny\, too organized to be just wear and tear \-\- it might be some type of glyph spell\./
				current_trap_type = "glyph"
				CharSettings['glyph'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Knowing how delicate magical glyphs can be\, you scrape some extra lines into the markings hoping to alter their meaning and defeat the spell they may hold\./
				current_trap_type = "Glyph trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /You notice some spiderweb\-like scratches on the lock plate which seem\, after some bit of scrutiny\, too organized to be just wear and tear \-\- it might be some type of glyph spell\, but some of the markings have been altered\.\s+This may prevent any magical nature they have from manifesting itself\./
				current_trap_type = "Glyph trap has already been disarmed."
				break
			#Already disarmed with 408
			#Trap can't be disarmed with 408
	#####Rods information#####
			#Manual detection
			elsif line =~ /Looking closely into the keyhole\, you notice a pair of small metal rods a hair\'s width from touching each other\.\s+Peering around the inside of the keyhole\, you can see that the lock would push the two rods together should the lock be tampered with\./
				current_trap_type = "rods"
				CharSettings['rods'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /With great care you take a pair of metal grips and bend the sensitive metal rods out of alignment\.\s+It looks as though they cannot be pressed together by the lock mechanism any more\./
				current_trap_type = "Rods trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /Looking closely into the keyhole\, you notice a pair of small metal rods that have been bent in opposite directions of each other\./
				current_trap_type = "Rods trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /Near the lock mechanism\, you notice a pair of small metal rods surrounded by a crimson glow\.|Looking closely into the keyhole\, you notice a pair of small metal rods that have a slight reddish glow about them\./
				current_trap_type = "Rods trap has already been disarmed with 408."
				break
	#####Boomer information#####
			#Manual detection
			elsif line =~ /Carefully\, you feel around the lock and notice the inside chamber is coated with a strange white substance\.\s+From your experience you recognize this as a common.*detonation system for an explosive mixture that was used to treat the .*(box|strongbox|chest|trunk|coffer)\./
				current_trap_type = "boomer"
				CharSettings['boomer'] += 1
				CharSettings['total_trap_count'] += 1
			#Successful manual disarm
			elsif line =~ /Using a bit of putty from your.*\, you cake a thin layer on the lock casing\, hopefully sufficient to prevent sparks when the metal arm strikes it\./
				current_trap_type = "Boomer trap has been disarmed."
				break
			#Already manually disarmed
			elsif line =~ /A thin layer of mud or putty has been dabbed on the connecting point of the striking arm and the white substance to prevent it from igniting the.*(box|strongbox|chest|trunk|coffer) when it is unlocked\./
				current_trap_type = "Boomer trap has already been disarmed."
				break
			#Already disarmed with 408
			elsif line =~ /A deep red glow surrounds the striking arm of the trap mechanism\.\s+You hope it will keep the arm from making contact with the explosive white substance\./
				current_trap_type = "Boomer trap has already been disarmed with 408."
				break
	#####No trap found#####
			elsif line =~ /You discover no traps\./
				current_trap_type = "No trap found."
				break
	#####Box is already open#####
			elsif line =~ /Um, but it\'s open/
				current_trap_type = "Box is already open."
				box_counts_for_math = nil
				break
	#####No putty#####
			elsif line =~ /You figure that if you had some sort of putty/
				echo "No putty to disarm this trap. Exiting."
				exit
	#####Roundtime#####
			elsif line =~ /Roundtime/
				break
			end

		end

		second_trap_check = true
		if (current_trap_type == "No trap found." || current_trap_type == "Scarab trap has already been disarmed." || current_trap_type == "Scarab trap has already been disarmed with 408." || current_trap_type == "Needle trap has been disarmed." || current_trap_type == "Needle trap has already been disarmed." || current_trap_type == "Needle trap has already been disarmed with 408." || current_trap_type == "Jaws trap has been disarmed." || current_trap_type == "Jaws trap has already been disarmed." || current_trap_type == "Sphere trap has been disarmed." || current_trap_type == "Sphere trap has already been disarmed." || current_trap_type == "Sphere trap has already been disarmed with 408." || current_trap_type == "Crystal trap has been disarmed." || current_trap_type == "Crystal trap has already been disarmed." || current_trap_type == "Crystal trap has already been disarmed with 408." || current_trap_type == "Scales trap has been disarmed." || current_trap_type == "Scales trap has already been disarmed." || current_trap_type == "Scales trap has already been disarmed with 408." || current_trap_type == "Sulphur trap has been disarmed." || current_trap_type == "Sulphur trap has already been disarmed." || current_trap_type == "Cloud trap has been disarmed." || current_trap_type == "Cloud trap has already been disarmed." || current_trap_type == "Cloud trap has already been disarmed with 408." || current_trap_type == "Acid vial trap has been disarmed." || current_trap_type == "Acid vial trap has already been disarmed." || current_trap_type == "Acid vial trap has already been disarmed with 408." || current_trap_type == "Springs trap has been disarmed." || current_trap_type == "Springs trap has already been disarmed with 408." || current_trap_type == "Fire vial trap has been disarmed." || current_trap_type == "Fire vial trap has already been disarmed." || current_trap_type == "Fire vial trap has already been disarmed with 408." || current_trap_type == "Spores trap has been disarmed." || current_trap_type == "Spores trap has already been disarmed." || current_trap_type == "Spores trap has already been disarmed with 408." || current_trap_type == "Plate trap has been disarmed." || current_trap_type == "Plate trap has already been disarmed." || current_trap_type == "Glyph trap has been disarmed." || current_trap_type == "Glyph trap has already been disarmed." || current_trap_type == "Rods trap has been disarmed." || current_trap_type == "Rods trap has already been disarmed." || current_trap_type == "Rods trap has already been disarmed with 408." || current_trap_type == "Boomer trap has been disarmed." || current_trap_type == "Boomer trap has already been disarmed." || current_trap_type == "Boomer trap has already been disarmed with 408." || current_trap_type == "Scarab trap has been disarmed." || current_trap_type == "Spores trap has already been set off." || current_trap_type == "Sphere trap has already been set off.")
			echo "#{current_trap_type}"
			(box_counts_for_math = nil) if (current_trap_type =~ /already/)
			number_of_manual_trap_checks_remaining -= 1
			if current_trap_type == "No trap found." && number_of_manual_trap_checks_remaining > 0
				echo "Number of trap checks remaining: #{number_of_manual_trap_checks_remaining}"
				second_trap_check = nil
				manually_disarm_trap.call
			else
				if current_trap_type == "No trap found."
					CharSettings['no_trap'] += 1
					CharSettings['total_trap_count'] += 1
				end
				waitrt?
				if UserVars.tpick["auto_bundle_vials"] == "yes" && (GameObj.right_hand.name =~ /vial/ || GameObj.left_hand.name =~ /vial/)
					check_locksmiths_container.call
					wait_until { vials_remaining }
					start_script "sorter" if start_sorter
					if vials_remaining < 10
						if GameObj.right_hand.name =~ /vial/
							current_vial = GameObj.right_hand.id
						elsif GameObj.left_hand.name =~ /vial/
							current_vial = GameObj.left_hand.id
						end
						fput "stow ##{current_vial}"
						tpick_stow_box(current_box) if (solo_or_other == "solo" || solo_or_other == "other")
						sleep 0.2
						stow_both.call
						wait_until { checkleft == nil }
						wait_until { checkright == nil }
						fput "remove ##{locksmiths_container.id}"
						wait_until { checkright != nil }
						fput "get ##{current_vial}"
						wait_until { checkleft != nil }
						fput "bundle"
						fput "wear ##{locksmiths_container.id}"
						wait_until { checkright == nil }
						if (solo_or_other == "solo" || solo_or_other == "other")
							tpick_get_box(current_box)
							wait_until { checkright }
						end				
					end
				end
				if current_trap_type == "Scarab trap has been disarmed."
					echo "Disarming scarab."
					waitrt?
					(tpick_cast_spells (506)) if (use_spell_506)
					sleep 1
					waitrt?
					fput "disarm scarab"
					waitrt?
					fput "get scarab"
					fput "stow my scarab"
				end
				stow_left.call
				stow_right.call if solo_or_other == "ground" || solo_or_other == "worker"
				if (disarm_only)
					if (bash_open_boxes)
						bash_the_box_open.call
					else
						box_counts_for_math = nil
						nil
					end
				else
					if always_use_wedge
						wedge_lock.call
					else
						measure.call
					end
				end
			end
		elsif current_trap_type == "Couldn't disarm trap, trying again."
			echo "#{current_trap_type}"
			tpick_cast_spells (404)
			manually_disarm_trap.call
		elsif current_trap_type == nil
			echo "Something went wrong on my end, repeating the DISARM command."
			tpick_cast_spells (404)
			manually_disarm_trap.call
		elsif (current_trap_type == "Acid vial trap has been set off." || current_trap_type == "Acid vial trap has already been set off.")
			echo "#{current_trap_type}"
			echo "Lock has been fused."
			if (disarm_only)
				if (bash_open_boxes)
					bash_the_box_open.call
				else
					box_counts_for_math = nil
					nil
				end
			else
				fused_lock_disarm.call
			end
		elsif current_trap_type == "Box is already open."
			echo "#{current_trap_type}"
			if solo_or_other == "solo"
				open_solo.call
			elsif solo_or_other == "other"
				open_others.call
			elsif solo_or_other == "ground"
				nil
			elsif solo_or_other == "worker"
				nil
			end
		elsif current_trap_type == "plate"
			echo "Found a #{current_trap_type} trap."
			if (disarm_only)
				if (bash_open_boxes)
					bash_the_box_open.call
				else
					box_counts_for_math = nil
					nil
				end
			else
				plate.call
			end
		elsif current_trap_type == "Jaws trap has already been disarmed with 408. Can't pick it." || current_trap_type == "Jaws trap has already been set off."
			echo "#{current_trap_type}"
			if (disarm_only)
				if (bash_open_boxes)
					bash_the_box_open.call
				else
					box_counts_for_math = nil
					nil
				end
			else
				fused_lock_disarm.call
			end
		else
			if current_trap_type == "Scales trap found, need to use dagger to disarm." || current_trap_type == "Sphere trap found, need to use lockpick to disarm."
				echo "#{current_trap_type}"
			else
				echo "Found a #{current_trap_type} trap."
			end
			if trap_cant_be_disarmed
				echo "Trap difficulty is too high according to your settings. Can't open box."
				if solo_or_other == "solo"
					where_to_stow_box.call
				elsif solo_or_other == "other"
					tpick_say_cant
					open_others.call
				elsif solo_or_other == "ground"
					cant_open_plated_box_count += 1
				elsif solo_or_other == "worker"
					ask_worker.call
				end
			else
				echo "Attempting to disarm trap." if current_trap_type != "scales" && second_trap_check == nil
				if current_trap_type == "scales"
					echo "Scales trap found, picking lock first then disarming."
					scale_trap_found = true
					measure.call
				elsif current_trap_type == "Scales trap found, need to use dagger to disarm."
					scaledisarm.call
				elsif (current_trap_type == "needle" || current_trap_type == "jaws" || current_trap_type == "crystal" || current_trap_type == "sulphur" || current_trap_type == "cloud" || current_trap_type == "acid vial" || current_trap_type == "springs" || current_trap_type == "fire vial" || current_trap_type == "spores" || current_trap_type == "glyph" || current_trap_type == "rods" || current_trap_type == "boomer" || current_trap_type == "sphere" || current_trap_type == "Sphere trap found, need to use lockpick to disarm." || current_trap_type == "scarab")
					manually_disarm_trap.call
				end
			end
		end
	end
}

open_all_containers = proc{
	open_or_close_containers = Array.new

	temp_container = UserVars.tpick["lockpick_container"].split(",")
	lockpick_container = temp_container[0]
	lockpick_container_close = true if temp_container[1] =~ /close/
	lockpick_container = GameObj.inv.find{ |i| i.name =~ /#{lockpick_container}/ }

	if lockpick_container.contents.nil? && !open_or_close_containers.include?(lockpick_container.id)
		open_or_close_containers.push(lockpick_container.id)
		fput "open ##{lockpick_container.id}"
	end

	temp_container = UserVars.tpick["broken_lockpick_container"].split(",")
	broken_lockpick_container = temp_container[0]
	broken_lockpick_container_close = true if temp_container[1] =~ /close/
	broken_lockpick_container = GameObj.inv.find{ |i| i.name =~ /#{broken_lockpick_container}/ }
	if broken_lockpick_container.contents.nil? && !open_or_close_containers.include?(broken_lockpick_container.id)
		open_or_close_containers.push(broken_lockpick_container.id)
		fput "open ##{broken_lockpick_container.id}"
	end

	temp_container = UserVars.tpick["wedge_container"].split(",")
	wedge_container = temp_container[0]
	wedge_container_close = true if temp_container[1] =~ /close/
	wedge_container = GameObj.inv.find{ |i| i.name =~ /#{wedge_container}/ }
	if wedge_container.contents.nil? && !open_or_close_containers.include?(wedge_container.id)
		open_or_close_containers.push(wedge_container.id)
		fput "open ##{wedge_container.id}"
	end

	temp_container = UserVars.tpick["calipers_container"].split(",")
	calipers_container = temp_container[0]
	calipers_container_close = true if temp_container[1] =~ /close/
	calipers_container = GameObj.inv.find{ |i| i.name =~ /#{calipers_container}/ }
	if calipers_container.contents.nil? && !open_or_close_containers.include?(calipers_container.id)
		open_or_close_containers.push(calipers_container.id)
		fput "open ##{calipers_container.id}"
	end

	temp_container = UserVars.tpick["scale_weapon_container"].split(",")
	scale_weapon_container = temp_container[0]
	scale_weapon_container_close = true if temp_container[1] =~ /close/
	scale_weapon_container = GameObj.inv.find{ |i| i.name =~ /#{scale_weapon_container}/ }
	if scale_weapon_container.contents.nil? && !open_or_close_containers.include?(scale_weapon_container.id)
		open_or_close_containers.push(scale_weapon_container.id)
		fput "open ##{scale_weapon_container.id}"
	end

	temp_container = UserVars.tpick["locksmiths_container"].split(",")
	locksmiths_container = temp_container[0]
	locksmiths_container_close = true if temp_container[1] =~ /close/
	locksmiths_container = GameObj.inv.find{ |i| i.name =~ /#{locksmiths_container}/ }
	if locksmiths_container.contents.nil? && !open_or_close_containers.include?(locksmiths_container.id)
		open_or_close_containers.push(locksmiths_container.id)
		fput "open ##{locksmiths_container.id}"
	end
	
	temp_container = UserVars.tpick["gem_container"].split(",")
	gem_container = temp_container[0]
	gem_container_close = true if temp_container[1] =~ /close/
	gem_container = GameObj.inv.find{ |i| i.name =~ /#{gem_container}/ }
	if gem_container.contents.nil? && !open_or_close_containers.include?(gem_container.id)
		open_or_close_containers.push(gem_container.id)
		fput "open ##{gem_container.id}"
	end
}

close_all_containers = proc{
	open_or_close_containers = Array.new
	open_or_close_containers.push(lockpick_container.id) if (lockpick_container_close) && (!open_or_close_containers.include?(lockpick_container.id))
	open_or_close_containers.push(broken_lockpick_container.id) if (broken_lockpick_container_close) && (!open_or_close_containers.include?(broken_lockpick_container.id))
	open_or_close_containers.push(wedge_container.id) if (wedge_container_close) && (!open_or_close_containers.include?(wedge_container.id))
	open_or_close_containers.push(calipers_container.id) if (calipers_container_close) && (!open_or_close_containers.include?(calipers_container.id))
	open_or_close_containers.push(scale_weapon_container.id) if (scale_weapon_container_close) && (!open_or_close_containers.include?(scale_weapon_container.id))
	open_or_close_containers.push(locksmiths_container.id) if (locksmiths_container_close) && (!open_or_close_containers.include?(locksmiths_container.id))
	open_or_close_containers.push(gem_container.id) if (gem_container_close) && (!open_or_close_containers.include?(gem_container.id))
	open_or_close_containers.each{ |i|
		waitrt?
		(fput "close ##{i}") unless i == nil
	}
}

scaledisarm = proc{
	echo "Attempting to disarm scales trap."
	3.times{
		waitrt?
		unless GameObj.right_hand.id == $scale_trap_weapon_id || GameObj.left_hand.id == $scale_trap_weapon_id
			fput "get ##{$scale_trap_weapon_id}"
			sleep 0.2
		end
	}
	if GameObj.right_hand.id != $scale_trap_weapon_id && GameObj.left_hand.id != $scale_trap_weapon_id
		echo "Couldn't find your #{UserVars.tpick["scale_trap_weapon"]}."
		exit
	end
	(tpick_cast_spells (404)) if (need_404 == "yes") || (use_spell_404)
	(tpick_cast_spells (506)) if (use_spell_506)
	(tpick_cast_spells (613)) if (use_spell_613)
	(tpick_cast_spells (1006)) if (use_spell_1006)
	result = dothistimeout "disarm ##{current_box.id}", 3, /slice through the cord/i
	if result =~ /slice through the cord/
		waitrt?
		if scale_weapon_container.nil?
			fput "put ##{$scale_trap_weapon_id} in my #{UserVars.tpick["scale_weapon_container"]}"
		else
			fput "put ##{$scale_trap_weapon_id} in ##{scale_weapon_container.id}"
		end
		if solo_or_other == "solo"
			open_solo.call
		elsif solo_or_other == "other"
			open_others.call
		elsif solo_or_other == "ground"
			sleep 0.1
		elsif solo_or_other == "worker"
			sleep 0.1
		end
	elsif result.nil?
		waitrt?
		if scale_weapon_container.nil?
			fput "put ##{$scale_trap_weapon_id} in my #{UserVars.tpick["scale_weapon_container"]}"
		else
			fput "put ##{$scale_trap_weapon_id} in ##{scale_weapon_container.id}"
		end
		tpick_cast_spells (404)
		scaledisarm.call
	end
}

plate = proc{
	echo "Disarming trap."
	waitrt?
	tpick_cast_spells (506) if use_spell_506
	if always_use_wedge
		wedge_lock.call
	else
		result = dothistimeout "disarm ##{current_box.id}", 3, /the metal plate covering the lock begins to melt away|Gonna chew through it|The darn thing is built too tightly|You still have a good enough picture of the trap in your mind/i
		if result =~ /the metal plate covering the lock begins to melt away/i
			measure.call
		elsif result =~ /Gonna chew through it|The darn thing is built too tightly|You still have a good enough picture of the trap in your mind/i and Char.prof == 'Rogue'
			echo "No vials found bundled in your locksmith's pouch, going to try wedging this box open."
			wedge_lock.call
		elsif result =~ /Gonna chew through it|The darn thing is built too tightly|You still have a good enough picture of the trap in your mind/i and Char.prof != 'Rogue' and (!Spell[407].known? or (UserVars.tpick["always_use_407"] != "plate" and UserVars.tpick["always_use_407"] != "all"))
			echo "Can't open this plated box."
			if solo_or_other == "solo"
				exit
			elsif solo_or_other == "other"
				tpick_say_cant
				open_others.call
			elsif solo_or_other == "ground"
				(cant_open_plated_box_count += 1;box_opened = nil)
			elsif solo_or_other == "worker"
				nil
			end
		elsif result =~ /Gonna chew through it/i and Char.prof != 'Rogue' and Spell[407].known? and UserVars.tpick["always_use_407"] == "plate"
			tpick_get_box(current_box) if solo_or_other == "ground"
			echo "Going to try popping this box."
			cast_407.call
		elsif result =~ /Gonna chew through it/i and Char.prof != 'Rogue' and Spell[407].known? and UserVars.tpick["always_use_407"] == "all"
			tpick_get_box(current_box) if solo_or_other == "ground"
			echo "Going to try popping this box."
			cast_407.call
		elsif result.nil?
			plate.call
		end
	end
}

measure = proc{
	stuff_to_do.call if solo_or_other == "solo"
	waitrt?
	(tpick_cast_spells (506)) if (use_spell_506)
	i_need_403 = nil
	if (always_use_vaalin)
		echo "Always use vaalin setting enabled, using a vaalin lockpick."
		needed_pick = UserVars.tpick["vaalin"]
		needed_pick_id = $vaalin_lockpick_id
		need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
		recommended_pick = "vaalin"
		recommended_pick_modifier = 2.50
		pick2.call
	elsif (UserVars.tpick["use_vaalin_when_fried"] =~ /yes/i) && ((percentmind >= 100))
		echo "Always use vaalin when fried enabled, using a vaalin lockpick."
		(box_counts_for_math = nil)
		needed_pick = UserVars.tpick["vaalin"]
		needed_pick_id = $vaalin_lockpick_id
		recommended_pick = "vaalin"
		recommended_pick_modifier = 2.50
		need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
		pick2.call
	elsif start_with_copper
		echo "Start with copper option enabled, starting with lockpick in your copper lockpick setting."
		needed_pick = UserVars.tpick["copper"]
		needed_pick_id = $copper_lockpick_id
		recommended_pick = "copper"
		recommended_pick_modifier = 1.00
		pick2.call	
	elsif UserVars.tpick["always_use_407"] == "all"
		echo "Always use 407 setting enabled, using 407."
		if (scale_trap_found)
			echo "Can't open a scales trap with 407."
			if solo_or_other == "solo"
				where_to_stow_box.call
			elsif solo_or_other == "other"
				tpick_say_cant
				open_others.call
			elsif solo_or_other == "ground"
				cant_open_plated_box_count += 1
				box_opened = nil
			elsif solo_or_other == "worker"
				ask_worker.call
			end
		else
			tpick_get_box(current_box) if solo_or_other == "ground"
			cast_407.call
		end
	else
		waitrt?
		if (found_true_lock_difficulty == nil)
			if Char.prof == 'Rogue'
				echo "Measuring lock."
				3.times{
					waitrt?
					unless GameObj.right_hand.name =~ /calipers/ || GameObj.left_hand.name =~ /calipers/
						fput "get my calipers"
						sleep 0.2
					end
				}
				if GameObj.right_hand.name !~ /calipers/ && GameObj.left_hand.name !~ /calipers/
					echo "Couldn't find your calipers."
					exit
				end
				fput "lmaster measure ##{current_box.id}"
			elsif Char.prof == 'Bard'
				echo "Loresinging to box to find out lock difficulty."
				tpick_get_box(current_box) if solo_or_other == "ground"
				fput "speak bard"
				if solo_or_other == "worker"
					fput "loresing ::#{checkname} #{current_box.noun} on table:: #{current_box.noun} that looks like a clock;What's the purpose of your lock?"
				else
					fput "loresing #{checkright} that I hold;let your purpose now be told"
				end
			end
			while line = get
				(lock = lock_difficulty[0];break) if line =~ /a primitive lock/i
				(lock = lock_difficulty[1];break) if line =~ /a rudimentary lock/i
				(lock = lock_difficulty[2];break) if line =~ /an extremely easy lock/i
				(lock = lock_difficulty[3];break) if line =~ /a very easy lock/i
				(lock = lock_difficulty[4];break) if line =~ /an easy lock/i
				(lock = lock_difficulty[5];break) if line =~ /a very basic lock/i
				(lock = lock_difficulty[6];break) if line =~ /a fairly easy lock/i
				(lock = lock_difficulty[7];break) if line =~ /a simple lock/i
				(lock = lock_difficulty[8];break) if line =~ /a fairly simple lock/i
				(lock = lock_difficulty[9];break) if line =~ /a fairly plain lock/i
				(lock = lock_difficulty[10];break) if line =~ /a moderately well-crafted lock/i
				(lock = lock_difficulty[11];break) if line =~ /a well-crafted lock/i
				(lock = lock_difficulty[12];break) if line =~ /a tricky lock/i
				(lock = lock_difficulty[13];break) if line =~ /a somewhat difficult lock/i
				(lock = lock_difficulty[14];break) if line =~ /a moderately difficult lock/i
				(lock = lock_difficulty[15];break) if line =~ /a very well-crafted lock/i
				(lock = lock_difficulty[16];break) if line =~ /a difficult lock/i
				(lock = lock_difficulty[17];break) if line =~ /an extremely well-crafted lock/i
				(lock = lock_difficulty[18];break) if line =~ /a very difficult lock/i
				(lock = lock_difficulty[19];break) if line =~ /a fairly complicated lock/i
				(lock = lock_difficulty[20];break) if line =~ /an intricate lock/i
				(lock = lock_difficulty[21];break) if line =~ /an amazingly well-crafted lock/i
				(lock = lock_difficulty[22];break) if line =~ /a very complex lock/i
				(lock = lock_difficulty[23];break) if line =~ /an impressively complicated lock/i
				(lock = lock_difficulty[24];break) if line =~ /an amazingly intricate lock/i
				(lock = lock_difficulty[25];break) if line =~ /an extremely difficult lock/i
				(lock = lock_difficulty[26];break) if line =~ /an extremely complex lock/i
				(lock = lock_difficulty[27];break) if line =~ /a masterfully well-crafted lock/i
				(lock = lock_difficulty[28];break) if line =~ /an amazingly complicated lock/i
				(lock = lock_difficulty[29];break) if line =~ /an astoundingly complex lock/i
				(lock = lock_difficulty[30];break) if line =~ /an incredibly intricate lock/i
				(lock = lock_difficulty[31];break) if line =~ /an absurdly well-crafted lock/i
				(lock = lock_difficulty[32];break) if line =~ /an exceedingly complex lock/i
				(lock = lock_difficulty[33];break) if line =~ /an absurdly difficult lock/i
				(lock = lock_difficulty[34];break) if line =~ /an unbelievably complicated lock/i
				(lock = lock_difficulty[35];break) if line =~ /a masterfully intricate lock/i
				(lock = lock_difficulty[36];break) if line =~ /an absurdly complex lock/i
				(lock = lock_difficulty[37];break) if line =~ /an impossibly complex lock/i
				(lock = "not locked";break) if line =~ /has already been unlocked/i
				(lock = "can't find trap";break) if line =~ /As you start to place the probe in the lock/
			end
			waitrt?
			fput "speak common" if Char.prof == 'Bard'
			if Char.prof == 'Rogue'
				stow_calipers.call
			elsif Char.prof == 'Bard' && solo_or_other == "ground"
				tpick_drop_box(current_box)
			end
		end
		number = 0
		needed_pick = nil
		needed_pick_id = nil
		if lock == "not locked"
			box_counts_for_math = nil
			if solo_or_other == "solo"
				open_solo.call
			elsif solo_or_other == "other"
				open_others.call
			elsif solo_or_other == "ground"
				nil
			elsif solo_or_other == "worker"
				nil
			end
		elsif lock == "can't find trap"
			echo "Doesn't look like you have the skill to detect the trap on this box."
			box_counts_for_math = nil
			if solo_or_other == "solo"
				where_to_stow_box.call
			elsif solo_or_other == "other"
				tpick_say_cant
				open_others.call
			elsif solo_or_other == "ground"
				nil
			elsif solo_or_other == "worker"
				ask_worker.call
			end
		else
			total_pick_skill = (pick_skill + pick_lore) * 2.50
			if lock > (total_pick_skill + UserVars.tpick["vaalin_lock_roll"].to_i)
				if (scale_trap_found)
					echo "Can't pick this box based on my calculations (and it has a scales trap.). If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
					if solo_or_other == "solo"
						where_to_stow_box.call
					elsif solo_or_other == "other"
						tpick_say_cant
						open_others.call
					elsif solo_or_other == "ground"
						cant_open_plated_box_count += 1
						box_opened = nil
					elsif solo_or_other == "worker"
						ask_worker.call
					end
				else
					echo "Can't pick this box based on my calculations. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
					wedge_lock.call
				end
			else
				pick_mod.each do |i|
					total_pick_skill = (pick_skill + pick_lore)
					if (total_pick_skill) * 2.50 - lock + UserVars.tpick["lock_roll"].to_i < 100
						needed_pick = UserVars.tpick["vaalin"]
						needed_pick_id = $vaalin_lockpick_id
						need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
						i_need_403 = true unless UserVars.tpick["always_use_403"] == "never"
						number = 15
						break
					else
						total_pick_skill = (pick_skill) * i
						if total_pick_skill - lock + UserVars.tpick["lock_roll"].to_i < 100
							number += 1
							unless UserVars.tpick["always_use_403"] == "never"
								i_need_403 = true if number > 14
							end
						else
							break
						end
					end
				end
				if i_need_403
					number = 0
					need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
					pick_mod.each do |i|
						total_pick_skill = (pick_skill + pick_lore) * i
						if total_pick_skill - lock + UserVars.tpick["lock_roll"].to_i < 100
							number += 1
						else
							break
						end
					end
				end
				if number == 0
					needed_pick = UserVars.tpick["copper"]
					needed_pick_id = $copper_lockpick_id
					recommended_pick = "copper"
					recommended_pick_modifier = 1.00
				elsif number == 1
					needed_pick = UserVars.tpick["steel"]
					needed_pick_id = $steel_lockpick_id
					recommended_pick = "steel"
					recommended_pick_modifier = 1.10
				elsif number == 2
					needed_pick = UserVars.tpick["gold"]
					needed_pick_id = $gold_lockpick_id
					recommended_pick = "gold"
					recommended_pick_modifier = 1.20
				elsif number == 3
					needed_pick = UserVars.tpick["silver"]
					needed_pick_id = $silver_lockpick_id
					recommended_pick = "silver"
					recommended_pick_modifier = 1.30
				elsif number == 4
					needed_pick = UserVars.tpick["mithril"]
					needed_pick_id = $mithril_lockpick_id
					recommended_pick = "mithril"
					recommended_pick_modifier = 1.45
				elsif number == 5
					needed_pick = UserVars.tpick["ora"]
					needed_pick_id = $ora_lockpick_id
					recommended_pick = "ora"
					recommended_pick_modifier = 1.55
				elsif number == 6
					needed_pick = UserVars.tpick["glaes"]
					needed_pick_id = $glaes_lockpick_id
					recommended_pick = "glaes"
					recommended_pick_modifier = 1.60
				elsif number == 7
					needed_pick = UserVars.tpick["laje"]
					needed_pick_id = $laje_lockpick_id
					recommended_pick = "laje"
					recommended_pick_modifier = 1.75
				elsif number == 8
					needed_pick = UserVars.tpick["vultite"]
					needed_pick_id = $vultite_lockpick_id
					recommended_pick = "vultite"
					recommended_pick_modifier = 1.80
				elsif number == 9
					needed_pick = UserVars.tpick["rolaren"]
					needed_pick_id = $rolaren_lockpick_id
					recommended_pick = "rolaren"
					recommended_pick_modifier = 1.90
				elsif number == 10
					needed_pick = UserVars.tpick["veniom"]
					needed_pick_id = $veniom_lockpick_id
					recommended_pick = "veniom"
					recommended_pick_modifier = 2.20
				elsif number == 11
					needed_pick = UserVars.tpick["invar"]
					needed_pick_id = $invar_lockpick_id
					recommended_pick = "invar"
					recommended_pick_modifier = 2.25
				elsif number == 12
					needed_pick = UserVars.tpick["alum"]
					needed_pick_id = $alum_lockpick_id
					recommended_pick = "alum"
					recommended_pick_modifier = 2.30
				elsif number == 13
					needed_pick = UserVars.tpick["golvern"]
					needed_pick_id = $golvern_lockpick_id
					recommended_pick = "golvern"
					recommended_pick_modifier = 2.35
				elsif number == 14
					needed_pick = UserVars.tpick["kelyn"]
					needed_pick_id = $kelyn_lockpick_id
					recommended_pick = "kelyn"
					recommended_pick_modifier = 2.40
				elsif number > 14
					needed_pick = UserVars.tpick["vaalin"]
					needed_pick_id = $vaalin_lockpick_id
					recommended_pick = "vaalin"
					recommended_pick_modifier = 2.50
				end
				echo "Recommended lock pick: #{recommended_pick} with a modifier of #{recommended_pick_modifier}"
				if need_403 == "yes"
					echo "Recommend 403: Yes"
					echo "Your calculated lockpicking skill: #{pick_skill}"
					echo "Your calculated lockpicking lore: #{pick_lore}"
					temp_math_number = pick_skill + pick_lore
				else
					echo "Recommend 403: No"
					echo "Your calculated lockpicking skill: #{pick_skill}"
					temp_math_number = pick_skill
				end
				quick_maths = (temp_math_number * recommended_pick_modifier).truncate
				echo "Your total picking skill for this attempt is: #{quick_maths}"
				echo "Lock difficulty: #{lock}"
				pick2.call
			end
		end
	end
}

find_gnomish_lockpick = proc{
	found_pick = nil
	spin_number = 0
	waitrt?
	fput "turn my #{gnomish_bracers}"
	while line = get
		if line =~ /^You spin your/
			(found_pick = true) if (line =~ /#{needed_pick}/)
			break
		end
	end
	if found_pick == nil
		loop{
			spin_number += 1
			waitrt?
			fput "spin my #{gnomish_bracers}"
			while line = get
				if line =~ /^You spin your/
					(found_pick = true) if (line =~ /#{needed_pick}/)
					break
				end
			end
			break if (found_pick) || (spin_number > 18)
		}
	end
	if (spin_number > 18)
		echo "Couldn't find the lockpick needed to pick this lock in your #{gnomish_bracers}."
		nextpick.call
	else
		pick3.call
	end
}

pick2 = proc{
	waitrt?
	if (gnomish_bracers)
		find_gnomish_lockpick.call
	else
		3.times{
			waitrt?
			unless GameObj.right_hand.id == needed_pick_id || GameObj.left_hand.id == needed_pick_id
				fput "get ##{needed_pick_id}"
				sleep 0.2
			end
		}
		if GameObj.right_hand.id != needed_pick_id && GameObj.left_hand.id != needed_pick_id
			echo "Couldn't find #{needed_pick}."
			waitrt?
			roll_amount = 100
			nextpick.call
		else
			pick3.call
		end
	end
}

pick3 = proc{
	next_task = nil
	roll_amount = nil
	if (open_plinites) || current_box.name =~ /plinite/
		echo "Attempting to extract plinite."
	else
		echo "Attempting to pick lock."
	end
	waitrt?
	(tpick_cast_spells (506)) if (use_spell_506)
	unless UserVars.tpick["always_use_403"] == "never"
		(tpick_cast_spells (403)) if (need_403 == "yes" || use_spell_403)
	end
	if (open_plinites) || current_box.name =~ /plinite/
		fput "extract ##{current_box.id}"
	elsif (gnomish_bracers)
		fput "push my #{gnomish_bracers}"
	else
		fput "#{do_trick} ##{current_box.id}"
	end
	if (open_plinites) || current_box.name =~ /plinite/
		while line = get
			if line =~ /\(d100\=(\d+)\)/
				roll_amount = $1.to_i
				if line =~ /fumbling attempt/
					waitrt?
					next_task = "pick3"
					break
				end
			elsif line =~ /As you do you so\, you push just a little too hard and rupture the core\!/
				waitrt?
				next_task = "next plinite"
				break
			elsif line =~ /you withdraw your lockpick with the feeling that retrieving the core is within your abilities/
				waitrt?
				next_task = "pick3"
				break
			elsif line =~ /with the feeling that your abilities are probably not sufficient to retrieve the core/
				stow_right.call if solo_or_other == "worker"
				stow_left.call
				if needed_pick == UserVars.tpick["vaalin"]
					if solo_or_other == "worker"
						echo "Can't extract this plinite based on my calculations. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
						next_task = "next plinite"
					else
						echo "Can't extract this plinite, OPENing it instead. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
						waitrt?
						fput "open ##{current_box.id}"
						next_task = "next plinite"
					end
				else
					next_task = "nextpick"
				end
				break
			elsif line =~ /where it can be easily PLUCKed/
				next_task = "open plinite"
				break
			end
		end
	else
		while line = get
			if line =~ /\(d100\=(\d+)\)/
				roll_amount = $1.to_i
				if line =~ /fumbling attempt/
					waitrt?
					next_task = "pick3"
					break
				end
			elsif line =~ /(You struggle with the .*\.  As you do\, you get a sense that the .* has .* \(.* thief\-lingo difficulty ranking\)\.  Then\.\.\.CLICK\!  It opens\!|It opens|as the tumblers snap open|It does not appear to be locked|already been unlocked)/
				if line =~ /(It does not appear to be locked|already been unlocked)/
					box_counts_for_math = nil
				end
				calibrate_count += 1
				waitrt?
				fput "put ##{needed_pick_id} in ##{lockpick_container.id}" unless gnomish_bracers
				if line =~ /You struggle with the .*\.  As you do\, you get a sense that the .* has .* \(.* thief\-lingo difficulty ranking\)\.  Then\.\.\.CLICK\!  It opens\!|It opens|as the tumblers snap open/i && calibrate_count >= UserVars.tpick["calibratecount"].to_i
					if can_use_calipers && always_use_vaalin.nil? && start_with_copper.nil?
						calibrate.call unless popping
					end
					calibrate_count = 0
				end
				if scale_trap_found
					scaledisarm.call
				elsif solo_or_other == "solo"
					next_task = "open_solo"
				elsif solo_or_other == "other"
					next_task = "open_other"
				elsif solo_or_other == "ground"
					tpick_drop_box(current_box) if gnomish_bracers
					next_task = "open_ground"
				elsif solo_or_other == "worker"
					next_task = "worker finished"
				end
				break
			elsif (line =~ /You are not able to pick the .*\, but you get a sense that it has .*\. About a \-(\d+) difficulty lock/) || (line =~ /(As you do\, you get a sense that the .* has .* \(\-(\d+) thief\-lingo difficulty ranking\))/) && (found_true_lock_difficulty == nil)
				lock = $1.to_i
				found_true_lock_difficulty = true
				next_task = "measure again"
				break
			elsif (line =~ /(bit more luck|within your abilities)/i) || ((line =~ /You are not able to pick the .*\, but you get a sense that it has .*\. About a \-(\d+) difficulty lock/) || (line =~ /(As you do\, you get a sense that the .* has .* \(\-(\d+) thief\-lingo difficulty ranking\))/) && (found_true_lock_difficulty))
				waitrt?
				if (roll_amount > UserVars.tpick["lock_roll"].to_i)
					fput "put ##{needed_pick_id} in ##{lockpick_container.id}" unless gnomish_bracers
					(next_task = "nextpick")
				else
					next_task = "pick3"
				end
				break
			elsif line =~ /(You are not able to pick|You carefully try to work it free but end up bending the tip|You carefully try to work it free\, but it may have been weakened by the stress\.)/i
				waitrt?
				if line =~ /You carefully try to work it free but end up bending the tip|You carefully try to work it free\, but it may have been weakened by the stress\./
					if UserVars.tpick["auto_repair_bent_lockpicks"] == "yes" && Char.prof =~ /Rogue/
						if solo_or_other != "ground" && solo_or_other != "worker"
							tpick_stow_box(current_box)
							fput "lmas repair my #{checkleft}"
							tpick_get_box(current_box)
						elsif solo_or_other == "ground" || solo_or_other == "worker"
							fput "lmas repair my #{checkright}"
						end
					end
					roll_amount = 100
					fput "put ##{needed_pick_id} in ##{lockpick_container.id}" unless gnomish_bracers
				elsif line =~ /You are not able to pick/ && needed_pick != UserVars.tpick["vaalin"]
					fput "put ##{needed_pick_id} in ##{lockpick_container.id}" unless gnomish_bracers
				elsif line =~ /You are not able to pick/ && needed_pick == UserVars.tpick["vaalin"]
					if roll_amount > UserVars.tpick["vaalin_lock_roll"].to_i
						fput "put ##{needed_pick_id} in ##{lockpick_container.id}" unless gnomish_bracers
						roll_amount = 100
					end
				end
				next_task = "nextpick"
				break
			elsif line =~ /(You broke your|you realize you are using a broken|You carefully try to work it free but end up snapping off the tip)/i
				echo "#{needed_pick} is broken."
				waitrt?
				next_task = "broken lockpick stow"
				break
			elsif line =~ /(You must be holding a lockpick to perform that trick.|You didn't mention what you want to pick the lock with.)/i
				echo "Couldn't find #{needed_pick}."
				waitrt?
				next_task = "nextpick"
				break
			end
		end
	end
	if next_task == "open_solo"
		open_solo.call
	elsif next_task == "open_other"
		open_others.call
	elsif next_task == "worker finished"
		nil
	elsif next_task == "open_ground"
		nil
	elsif next_task == "pick3"
		pick3.call
	elsif next_task == "nextpick"
		nextpick.call
	elsif next_task == "measure again"
		echo "Got a read on this box, going to change to best suited lockpick."
		measure.call
	elsif next_task == "broken lockpick stow"
		if gnomish_bracers
			nextpick.call
		else
			broken_lockpick_stow.call
		end
	elsif next_task == "open plinite"
		if solo_or_other == "worker"
			ask_worker.call
		else
			open_current_plinite.call
		end
	elsif next_task == "next plinite"
		stow_both.call
		ask_worker.call if solo_or_other == "worker"
	end
}

broken_lockpick_stow = proc{
	3.times{
		waitrt?
		unless GameObj.right_hand.id != needed_pick_id && GameObj.left_hand.id != needed_pick_id
			fput "put ##{needed_pick_id} in ##{broken_lockpick_container.id}"
			sleep 0.2
		end
	}
	if GameObj.right_hand.id == needed_pick_id || GameObj.left_hand.id == needed_pick_id
		echo "Couldn't put lockpick in your #{broken_lockpick_container}."
		sleep 2
		fput "stow ##{needed_pick_id}"
	end
	roll_amount = 100
	nextpick.call
}

nextpick = proc{
	before_needed_pick = needed_pick
	before_recommended_pick = recommended_pick
	if recommended_pick == "copper"
		needed_pick = UserVars.tpick["steel"]
		needed_pick_id = $steel_lockpick_id
		recommended_pick = "steel"
	elsif recommended_pick == "steel"
		needed_pick = UserVars.tpick["gold"]
		needed_pick_id = $gold_lockpick_id
		recommended_pick = "gold"
	elsif recommended_pick == "gold"
		needed_pick = UserVars.tpick["silver"]
		needed_pick_id = $silver_lockpick_id
		recommended_pick = "silver"
	elsif recommended_pick == "silver"
		needed_pick = UserVars.tpick["mithril"]
		needed_pick_id = $mithril_lockpick_id
		recommended_pick = "mithril"
	elsif recommended_pick == "mithril"
		needed_pick = UserVars.tpick["ora"]
		needed_pick_id = $ora_lockpick_id
		recommended_pick = "ora"
	elsif recommended_pick == "ora"
		needed_pick = UserVars.tpick["glaes"]
		needed_pick_id = $glaes_lockpick_id
		recommended_pick = "glaes"
	elsif recommended_pick == "glaes"
		needed_pick = UserVars.tpick["laje"]
		needed_pick_id = $laje_lockpick_id
		recommended_pick = "laje"
	elsif recommended_pick == "laje"
		needed_pick = UserVars.tpick["vultite"]
		needed_pick_id = $vultite_lockpick_id
		recommended_pick = "vultite"
	elsif recommended_pick == "vultite"
		needed_pick = UserVars.tpick["rolaren"]
		needed_pick_id = $rolaren_lockpick_id
		recommended_pick = "rolaren"
	elsif recommended_pick == "rolaren"
		needed_pick = UserVars.tpick["veniom"]
		needed_pick_id = $veniom_lockpick_id
		recommended_pick = "veniom"
	elsif recommended_pick == "veniom"
		needed_pick = UserVars.tpick["invar"]
		needed_pick_id = $invar_lockpick_id
		recommended_pick = "invar"
	elsif recommended_pick == "invar"
		needed_pick = UserVars.tpick["alum"]
		needed_pick_id = $alum_lockpick_id
		recommended_pick = "alum"
	elsif recommended_pick == "alum"
		needed_pick = UserVars.tpick["golvern"]
		needed_pick_id = $golvern_lockpick_id
		recommended_pick = "golvern"
	elsif recommended_pick == "golvern"
		needed_pick = UserVars.tpick["kelyn"]
		needed_pick_id = $kelyn_lockpick_id
		recommended_pick = "kelyn"
	elsif recommended_pick == "kelyn"
		need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
		needed_pick = UserVars.tpick["vaalin"]
		needed_pick_id = $vaalin_lockpick_id
		recommended_pick = "vaalin"
	elsif recommended_pick == "vaalin" && roll_amount != 100
		need_403 = "yes" unless UserVars.tpick["always_use_403"] == "never"
		needed_pick = UserVars.tpick["vaalin"]
		needed_pick_id = $vaalin_lockpick_id
		recommended_pick = "vaalin"
	elsif recommended_pick == "vaalin" && roll_amount == 100
		needed_pick = "wedge"
	end
	if before_needed_pick == needed_pick && recommended_pick != "vaalin"
		nextpick.call
	else
		nextpick2.call
	end
}

nextpick2 = proc{
	if needed_pick == "wedge"
		if open_plinites || current_box.name =~ /plinite/
			if solo_or_other == "worker"
				echo "Can't extract this plinite based on my calculations. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
				ask_worker.call
			else
				echo "Can't extract this plinite, OPENing it instead. If you think this is in error increase the Vaalin Lock Roll setting in the setup menu."
				waitrt?
				fput "open ##{current_box.id}"
			end
		elsif (scale_trap_found)
			echo "Can't pick this box and it has a scales trap."
			if solo_or_other == "solo"
				where_to_stow_box.call
			elsif solo_or_other == "other"
				tpick_say_cant
				open_others.call
			elsif solo_or_other == "ground"
				cant_open_plated_box_count += 1
				box_opened = nil
			end
		else
			if Char.prof =~ /Rogue/
				echo "Can't pick this lock, going to try to wedge it open."
				wedge_lock.call
			elsif Spell[407].known?
				echo "Can't pick this lock, going to try to pop it open."
				cast_407.call
			else
				if solo_or_other == "other"
					tpick_say_cant
					open_others.call
				elsif solo_or_other == "ground"
					echo "Couldn't open this box."
					box_opened = nil
				elsif solo_or_other == "solo"
					echo "Couldn't open this box."
					where_to_stow_box.call
					stow_both.call
					sleep 0.1
				end
			end
		end
	elsif before_needed_pick == UserVars.tpick["vaalin"]
		echo "Trying to pick with vaalin lockpick again."
		pick2.call
	else
		echo "Couldn't pick lock with #{before_recommended_pick} pick, trying #{recommended_pick} pick."
		pick2.call
	end
}

total_boxes_picked_math = proc{
	if (update_math_information)
		if (box_counts_for_math == nil)
			echo "This box was not added to your total boxes picked nor was the time spent opening it recorded."
		else
			total_picking_time = (Time.now - start_time)
			CharSettings['total_boxes_picked'] += 1
			(CharSettings['total_time_spent_picking_boxes'] += total_picking_time)
		end
		total_boxes_number -= 1
	end
	CharSettings['total_time_spent_picking_boxes'] = CharSettings['total_time_spent_picking_boxes'].round(2) unless CharSettings['total_time_spent_picking_boxes'] == 0
	average_picking_time = (CharSettings['total_time_spent_picking_boxes'] / CharSettings['total_boxes_picked']).round(2) unless CharSettings['total_boxes_picked'] == 0
	if CharSettings['total_boxes_picked'] > 0
		respond "\n"
		respond "####################"
		respond "####################"
		respond "Total boxes picked: #{CharSettings['total_boxes_picked']}"
		respond "Total time picking: #{CharSettings['total_time_spent_picking_boxes']} seconds"
		respond "Average time per box: #{average_picking_time} seconds"
		respond "####################"
		respond "####################"
		respond "\n"
	end
	(calculate_time_left = (total_boxes_number * average_picking_time).round(2)) unless CharSettings['total_boxes_picked'] == 0
	respond "\n"
	respond "####################"
	respond "####################"
	respond "Boxes remaining: #{total_boxes_number}"
	(respond "Estimated time remaining: #{calculate_time_left} seconds") unless CharSettings['total_boxes_picked'] == 0
	respond "####################"
	respond "####################"
	respond "\n"
	box_counts_for_math = true
}

open_solo = proc{
	update_math_information = true
	total_boxes_picked_math.call
	waitrt?
	(tpick_cast_spells (506)) if (use_spell_506)	
	total_boxes_picked += 1
	fput "open ##{current_box.id}" unless popping
	lootbox = GameObj.right_hand
	(dothistimeout "look in my #{lootbox}", 10, /In .*? you see|In the .*\:|There is nothing in/) if lootbox.contents.nil?
	waitrt?
	fput "swap"
	lootbox.contents.each{|item|
		waitrt?
		if (item.name !~ /urglaes fang/) && (item.name !~ /doomstone/)
			fput "get #{item} from ##{current_box.id}"
			if item.name =~ /coins/
				while line = get
					if line =~ /You gather the remaining (\d+) coins?/
						if $1.to_i < 625
							sleep 0.1
						else
							while line = get
								if line =~ /Roundtime\: (\d+) sec/
									sleep ($1.to_i + 1)
									break
								end
							end									
						end
						waitrt?
						break
					end
				end
			end
		end
		if item.name !~ /coins/i && UserVars.tpick["log"] == "yes"
			record_item_data.call
		end
		waitrt?
		if item.name !~ /coins/i && item.name !~ /urglaes fang/ && item.name !~ /doomstone/
			if UserVars.tpick["auto_bundle_vials"] == "yes" && item.name =~ /vial/ && (GameObj.right_hand.name =~ /vial/ || GameObj.left_hand.name =~ /vial/)
				check_locksmiths_container.call
				wait_until { vials_remaining }
				start_script "sorter" if start_sorter
				if vials_remaining < 10
					if GameObj.right_hand.name =~ /vial/
						current_vial = GameObj.right_hand.id
					elsif GameObj.left_hand.name =~ /vial/
						current_vial = GameObj.left_hand.id
					end
					fput "stow ##{current_vial}"
					tpick_stow_box(current_box)
					sleep 0.2
					stow_both.call
					wait_until { checkleft.nil? }
					wait_until { checkright.nil? }
					fput "remove ##{locksmiths_container.id}"
					wait_until { checkright }
					fput "get ##{current_vial}"
					wait_until { checkleft }
					fput "bundle"
					fput "wear ##{locksmiths_container.id}"
					wait_until { checkright.nil? }
					tpick_get_box(current_box)
					wait_until { checkright }			
				end
			else
				if (item.type =~ /gem/) && (gem_container)
					fput "put #{item} in ##{gem_container.id}"
				else
					fput "stow #{item}"
				end
			end
		end
		waitrt?
	}
	do_relock_boxes.call if relock_boxes
	garbage_check.call
	if box != "none"
		stow_both.call
		sleep 0.1
	else
		stow_both.call
	end
}

garbage_check = proc{
	waitrt?
	if UserVars.tpick["trash_boxes"] == "yes"
		if checkroom =~ /table|booth/i
			tpick_drop_box(current_box) if solo_or_other == "solo"
			fput "clean table"
		elsif GameObj.loot.find { |loot| trash = loot if loot.name =~ trash_container }
			waitrt?
			tpick_get_box(current_box) if solo_or_other == "ground"
			fput "put ##{current_box.id} in #{trash}"
		else
			tpick_drop_box(current_box) if solo_or_other == "solo"
		end
	elsif UserVars.tpick["trash_boxes"] == "save"
		result = dothistimeout "stow ##{current_box.id}", 3, /won\'t fit in|You put/
		if result =~ /won\'t fit in/i
			fput "put ##{current_box.id} in my #{UserVars.lootsack2}"
		elsif result =~ /You put/i
			nil
		elsif result.nil?
			tpick_stow_box(current_box)
		end
	else
		tpick_drop_box(current_box) if solo_or_other == "solo"
	end
	waitrt?
}

record_item_data = proc{
		if GameObj.right_hand.type =~ /gem/i
			gem = Array.new if gem == nil
			(gem.push(GameObj.right_hand.name);gem_number[gem.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /reagent/i
			reagent = Array.new if reagent == nil
			(reagent.push(GameObj.right_hand.name);reagent_number[reagent.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /herb/i
			herb = Array.new if herb == nil
			(herb.push(GameObj.right_hand.name);herb_number[herb.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /food/i
			food = Array.new if food == nil
			(food.push(GameObj.right_hand.name);food_number[food.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /uncommon/i
			uncommon = Array.new if uncommon == nil
			(uncommon.push(GameObj.right_hand.name);uncommon_number[uncommon.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /jewelry/i
			jewelry = Array.new if jewelry == nil
			(jewelry.push(GameObj.right_hand.name);jewelry_number[jewelry.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /junk/i
			junk = Array.new if junk == nil
			(junk.push(GameObj.right_hand.name);junk_number[junk.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /lockpick/i
			lockpick = Array.new if lockpick == nil
			(lockpick.push(GameObj.right_hand.name);lockpick_number[lockpick.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /magic/i
			magic = Array.new if magic == nil
			(magic.push(GameObj.right_hand.name);magic_number[magic.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /scroll/i
			scroll = Array.new if scroll == nil
			(scroll.push(GameObj.right_hand.name);scroll_number[scroll.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /wand/i
			wand = Array.new if wand == nil
			(wand.push(GameObj.right_hand.name);wand_number[wand.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /armor/i
			armor = Array.new if armor == nil
			(armor.push(GameObj.right_hand.name);armor_number[armor.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /weapon/i
			weapon = Array.new if weapon == nil
			(weapon.push(GameObj.right_hand.name);weapon_number[weapon.index(GameObj.right_hand.name)] += 1)
		elsif GameObj.right_hand.type =~ /clothing/i
			clothing = Array.new if clothing == nil
			(clothing.push(GameObj.right_hand.name);clothing_number[clothing.index(GameObj.right_hand.name)] += 1)
		else
			other = Array.new if other == nil
			(other.push(GameObj.right_hand.name);other_number[other.index(GameObj.right_hand.name)] += 1)
		end
}

open_others = proc{
	update_math_information = true
	total_boxes_picked_math.call
	waitrt?
	fput "give ##{current_box.id} to #{person}"
	start_others.call
}

before_dying { 
	if ground_loot || solo_or_other == "solo"
		wealth_after.call
		wait_until { silver_after }
		silver_gained = silver_after - silver_before
	end;
	
	DownstreamHook.remove("#{script.name}_check_locksmiths_container")
	DownstreamHook.remove("#{script.name}_check_for_boxes")
	DownstreamHook.remove("#{script.name}_wealth_before")
	DownstreamHook.remove("#{script.name}_wealth_after")

	respond "Total boxes picked: #{total_boxes_picked}" if ground_loot || solo_or_other == "solo"
	respond "Total silvers gained: #{silver_gained}" if ground_loot || solo_or_other == "solo"
	(gem.uniq! if gem != nil;reagent.uniq! if reagent != nil;herb.uniq! if herb != nil;food.uniq! if food != nil;uncommon.uniq! if uncommon != nil;jewelry.uniq! if jewelry != nil;junk.uniq! if junk != nil;lockpick.uniq!if lockpick != nil;magic.uniq! if magic != nil;scroll.uniq! if scroll != nil;wand.uniq! if wand != nil;armor.uniq! if armor != nil;weapon.uniq! if weapon != nil;other.uniq! if other != nil;clothing.uniq if clothing != nil) if ground_loot || solo_or_other == "solo"
	(respond "\nGems:\n";gem.each{|item|respond "#{item} x#{gem_number[gem.index(item)]}"}) if gem != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nReagents:\n";reagent.each{|item|respond "#{item} x#{reagent_number[reagent.index(item)]}"}) if reagent != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nHerbs:\n";herb.each{|item|respond "#{item} x#{herb_number[herb.index(item)]}"}) if herb != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nFood:\n";food.each{|item|respond "#{item} x#{food_number[food.index(item)]}"}) if food != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nUncommon:\n";uncommon.each{|item|respond "#{item} x#{uncommon_number[uncommon.index(item)]}"}) if uncommon != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nJewelry:\n";jewelry.each{|item|respond "#{item} x#{jewelry_number[jewelry.index(item)]}"}) if jewelry != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nJunk:\n";junk.each{|item|respond "#{item} x#{junk_number[junk.index(item)]}"}) if junk != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nLockpicks:\n";lockpick.each{|item|respond "#{item} x#{lockpick_number[lockpick.index(item)]}"}) if lockpick != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nMagic:\n";magic.each{|item|respond "#{item} x#{magic_number[magic.index(item)]}"}) if magic != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nScrolls:\n";scroll.each{|item|respond "#{item} x#{scroll_number[scroll.index(item)]}"}) if scroll != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nWands:\n";wand.each{|item|respond "#{item} x#{wand_number[wand.index(item)]}"}) if wand != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nArmor:\n";armor.each{|item|respond "#{item} x#{armor_number[armor.index(item)]}"}) if armor != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nWeapons:\n";weapon.each{|item|respond "#{item} x#{weapon_number[weapon.index(item)]}"}) if weapon != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nClothing:\n";clothing.each{|item|respond "#{item} x#{clothing_number[clothing.index(item)]}"}) if clothing != nil and (ground_loot or solo_or_other == "solo")
	(respond "\nOther:\n";other.each{|item|respond "#{item} x#{other_number[other.index(item)]}"}) if other != nil and (ground_loot or solo_or_other == "solo")
	close_all_containers.call
}

gem = nil
reagent = nil
herb = nil
food = nil
uncommon = nil
jewelry = nil
junk = nil
lockpick = nil
magic = nil
scroll = nil
wand = nil
armor = nil
weapon = nil
clothing = nil
other = nil

gem_number = Array.new
reagent_number = Array.new
herb_number = Array.new
food_number = Array.new
uncommon_number = Array.new
jewelry_number = Array.new
junk_number = Array.new
lockpick_number = Array.new
magic_number = Array.new
scroll_number = Array.new
wand_number = Array.new
armor_number = Array.new
weapon_number = Array.new
clothing_number = Array.new
other_number = Array.new

wealth_before = proc {
	action = proc { |server_string|
		if server_string =~ /^\s*Name\:|^\s*Gender\:|^\s*Normal \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/
			nil
		elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
			silver_before = $1.to_i
			DownstreamHook.remove("#{script.name}_wealth_before")
			nil
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_wealth_before", action)
		silence_me
		fput "info"
		silence_me
}

wealth_after = proc{
	action = proc { |server_string|
		if server_string =~ /^\s*Name\:|^\s*Gender\:|^\s*Normal \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/
			nil
		elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
			silver_after = $1.to_i
			DownstreamHook.remove("#{script.name}_wealth_after")
			nil
		else
			server_string
		end
	}
		DownstreamHook.add("#{script.name}_wealth_after", action)
		silence_me
		put "info"
		silence_me
}

stow_both = proc{
	stow_right.call
	stow_left.call
}

stow_right = proc{
	if checkright
		if (GameObj.right_hand.id == $copper_lockpick_id) || (GameObj.right_hand.id == $steel_lockpick_id) || (GameObj.right_hand.id == $gold_lockpick_id) || (GameObj.right_hand.id == $silver_lockpick_id) || (GameObj.right_hand.id == $mithril_lockpick_id) || (GameObj.right_hand.id == $ora_lockpick_id) || (GameObj.right_hand.id == $glaes_lockpick_id) || (GameObj.right_hand.id == $laje_lockpick_id) || (GameObj.right_hand.id == $vultite_lockpick_id) || (GameObj.right_hand.id == $rolaren_lockpick_id) || (GameObj.right_hand.id == $veniom_lockpick_id) || (GameObj.right_hand.id == $invar_lockpick_id) || (GameObj.right_hand.id == $alum_lockpick_id) || (GameObj.right_hand.id == $golvern_lockpick_id) || (GameObj.right_hand.id == $kelyn_lockpick_id) || (GameObj.right_hand.id == $vaalin_lockpick_id)
			until checkright.nil?
				waitrt?
				fput "put right in ##{lockpick_container.id}"
				sleep 0.2
			end
		elsif GameObj.right_hand.name =~ /wedge/
			until checkright.nil?
				waitrt?
				fput "put right in ##{wedge_container}"
				sleep 0.2
			end
		elsif GameObj.right_hand.name =~ /caliper/
			until checkright.nil?
				waitrt?
				fput "put right in ##{calipers_container.id}"
				sleep 0.2
			end
		elsif GameObj.right_hand.id == $scale_trap_weapon_id
			until checkright.nil?
				waitrt?
				if scale_weapon_container.nil?
					fput "put ##{$scale_trap_weapon_id} in my #{UserVars.tpick["scale_weapon_container"]}"
				else
					fput "put ##{$scale_trap_weapon_id} in ##{scale_weapon_container.id}"
				end
				sleep 0.2
			end
		else
			until checkright.nil?
				waitrt?
				fput "stow right"
				sleep 0.2
			end
		end
	end
}

stow_left = proc{
	if checkleft
		if (GameObj.left_hand.id == $copper_lockpick_id) || (GameObj.left_hand.id == $steel_lockpick_id) || (GameObj.left_hand.id == $gold_lockpick_id) || (GameObj.left_hand.id == $silver_lockpick_id) || (GameObj.left_hand.id == $mithril_lockpick_id) || (GameObj.left_hand.id == $ora_lockpick_id) || (GameObj.left_hand.id == $glaes_lockpick_id) || (GameObj.left_hand.id == $laje_lockpick_id) || (GameObj.left_hand.id == $vultite_lockpick_id) || (GameObj.left_hand.id == $rolaren_lockpick_id) || (GameObj.left_hand.id == $veniom_lockpick_id) || (GameObj.left_hand.id == $invar_lockpick_id) || (GameObj.left_hand.id == $alum_lockpick_id) || (GameObj.left_hand.id == $golvern_lockpick_id) || (GameObj.left_hand.id == $kelyn_lockpick_id) || (GameObj.left_hand.id == $vaalin_lockpick_id)
			until checkleft.nil?
				waitrt?
				fput "put left in ##{lockpick_container.id}"
				sleep 0.2
			end
		elsif GameObj.left_hand.name =~ /wedge/
			until checkleft.nil?
				waitrt?
				fput "put left in ##{wedge_container.id}"
				sleep 0.2
			end
		elsif GameObj.left_hand.name =~ /caliper/
			until checkleft.nil?
				waitrt?
				fput "put left in ##{calipers_container.id}"
				sleep 0.2
			end
		elsif GameObj.left_hand.id == $scale_trap_weapon_id
			until checkleft.nil?
				waitrt?
				if scale_weapon_container.nil?
					fput "put ##{$scale_trap_weapon_id} in my #{UserVars.tpick["scale_weapon_container"]}"
				else
					fput "put ##{$scale_trap_weapon_id} in ##{scale_weapon_container.id}"
				end
				sleep 0.2
			end
		else
			until checkleft.nil?
				waitrt?
				fput "stow left"
				sleep 0.2
			end
		end
	end
}
					
get_wire_order_numbers = proc{
	move 'out' if checkpaths 'out'
	target_room = Room.current.find_nearest(toolbenches_room_number)
	start_script 'go2', [ target_room.to_s ]
	wait_while{ running?('go2') }
	move 'go toolbench'
	fput "read sign"
	while line = get
		if line =~ /\s*(\d+)\..*copper wire\s+(\d+)/
			$tpick_copper_wire = $1
			$tpick_copper_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*brass wire\s+(\d+)/
			$tpick_brass_wire = $1
			$tpick_brass_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*steel wire\s+(\d+)/
			$tpick_steel_wire = $1
			$tpick_steel_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*gold wire\s+(\d+)/
			$tpick_gold_wire = $1
			$tpick_gold_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*silver wire\s+(\d+)/
			$tpick_silver_wire = $1
			$tpick_silver_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*ora wire\s+(\d+)/
			$tpick_ora_wire = $1
			$tpick_ora_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*mithril wire\s+(\d+)/
			$tpick_mithril_wire = $1
			$tpick_mithril_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*laje wire\s+(\d+)/
			$tpick_laje_wire = $1
			$tpick_laje_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*alum wire\s+(\d+)/
			$tpick_alum_wire = $1
			$tpick_alum_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*vultite wire\s+(\d+)/
			$tpick_vultite_wire = $1
			$tpick_vultite_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*rolaren wire\s+(\d+)/
			$tpick_rolaren_wire = $1
			$tpick_rolaren_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*veniom wire\s+(\d+)/
			$tpick_veniom_wire = $1
			$tpick_veniom_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*kelyn wire\s+(\d+)/
			$tpick_kelyn_wire = $1
			$tpick_kelyn_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*invar wire\s+(\d+)/
			$tpick_invar_wire = $1
			$tpick_invar_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*golvern wire\s+(\d+)/
			$tpick_golvern_wire = $1
			$tpick_golvern_wire_cost = $2
		elsif line =~ /\s*(\d+)\..*vaalin wire\s+(\d+)/
			$tpick_vaalin_wire = $1
			$tpick_vaalin_wire_cost = $2
		elsif line =~ /a thin bar of vaalin/
			break
		end
	end
	move 'out' if checkpaths 'out'
}

if (CharSettings['setup_has_been_run'].nil? || CharSettings['setup_has_been_run_again'].nil?|| UserVars.tpick.nil?) and (script.vars[1] != 'setup')
	echo "Setup is required, type ;tpick setup and fill in all settings."
	echo "If you are upgrading to a new version of ;tpick keep in mind all lockpick settings AND container names AND scale trap weapon now require the full name of each lockpick, not including the words 'a' and 'an'."	
	exit
end
if script.vars[1] == 'setup'
	setup.call
	exit
end

if UserVars.tpick["trap_roll"].length <= 0 || UserVars.tpick["lock_roll"].length <= 0 || UserVars.tpick["vaalin_lock_roll"].length <= 0
	echo "One or more of the following settings isn't setup properly: Trap Roll, Lock Roll, Vaalin Lock Roll."
	echo "These settings are found in the \"Options\" tab of the setup menu. Run ;tpick setup, click on the \"Options\" tab, read the instructions on the bottom, and please fill in these values."
	exit
end

if script.vars[1] =~ /stat/
	stats_check.call
	exit
end

if (UserVars.tpick["gnomish_bracer"] != "nil") && (UserVars.tpick["gnomish_bracer"] != nil) && (UserVars.tpick["gnomish_bracer"].length > 1)
	bracers_temp = UserVars.tpick["gnomish_bracer"].split(",")
	bracers_name = bracers_temp[0]
	bracers_tier = bracers_temp[1]
	gnomish_bracers = bracers_name
end

open_all_containers.call

until checkright.nil?
	waitrt?
	fput "stow right"
	sleep 0.1
end

until checkleft.nil?
	waitrt?
	fput "stow left"
	sleep 0.1
end

$tpick_boxes_checked = nil
check_for_lockpicks_etc.call
wait_until { $tpick_boxes_checked }

(echo "Couldn't find your copper lockpick";sleep 2) if $copper_lockpick_id.nil? && UserVars.tpick["copper"] != "nil" && UserVars.tpick["copper"].length > 1
(echo "Couldn't find your steel lockpick";sleep 2) if $steel_lockpick_id.nil? && UserVars.tpick["steel"] != "nil" && UserVars.tpick["steel"].length > 1
(echo "Couldn't find your gold lockpick";sleep 2) if $gold_lockpick_id.nil? && UserVars.tpick["gold"] != "nil" && UserVars.tpick["gold"].length > 1
(echo "Couldn't find your silver lockpick";sleep 2) if $silver_lockpick_id.nil? && UserVars.tpick["silver"] != "nil" && UserVars.tpick["silver"].length > 1
(echo "Couldn't find your mithril lockpick";sleep 2) if $mithril_lockpick_id.nil? && UserVars.tpick["mithril"] != "nil" && UserVars.tpick["mithril"].length > 1
(echo "Couldn't find your ora lockpick";sleep 2) if $ora_lockpick_id.nil? && UserVars.tpick["ora"] != "nil" && UserVars.tpick["ora"].length > 1
(echo "Couldn't find your glaes lockpick";sleep 2) if $glaes_lockpick_id.nil? && UserVars.tpick["glaes"] != "nil" && UserVars.tpick["glaes"].length > 1
(echo "Couldn't find your laje lockpick";sleep 2) if $laje_lockpick_id.nil? && UserVars.tpick["laje"] != "nil" && UserVars.tpick["laje"].length > 1
(echo "Couldn't find your vultite lockpick";sleep 2) if $vultite_lockpick_id.nil? && UserVars.tpick["vultite"] != "nil" && UserVars.tpick["vultite"].length > 1
(echo "Couldn't find your rolaren lockpick";sleep 2) if $rolaren_lockpick_id.nil? && UserVars.tpick["rolaren"] != "nil" && UserVars.tpick["rolaren"].length > 1
(echo "Couldn't find your veniom lockpick";sleep 2) if $veniom_lockpick_id.nil? && UserVars.tpick["veniom"] != "nil" && UserVars.tpick["veniom"].length > 1
(echo "Couldn't find your invar lockpick";sleep 2) if $invar_lockpick_id.nil? && UserVars.tpick["invar"] != "nil" && UserVars.tpick["invar"].length > 1
(echo "Couldn't find your alum lockpick";sleep 2) if $alum_lockpick_id.nil? && UserVars.tpick["alum"] != "nil" && UserVars.tpick["alum"].length > 1
(echo "Couldn't find your golvern lockpick";sleep 2) if $golvern_lockpick_id.nil? && UserVars.tpick["golvern"] != "nil" && UserVars.tpick["golvern"].length > 1
(echo "Couldn't find your kelyn lockpick";sleep 2) if $kelyn_lockpick_id.nil? && UserVars.tpick["kelyn"] != "nil" && UserVars.tpick["kelyn"].length > 1
(echo "Couldn't find your vaalin lockpick";sleep 2) if $vaalin_lockpick_id.nil? && UserVars.tpick["vaalin"] != "nil" && UserVars.tpick["vaalin"].length > 1
(echo "Couldn't find your scale trap weapon";sleep 2) if $scale_trap_weapon_id.nil? && UserVars.tpick["scale_trap_weapon"] != "nil" && UserVars.tpick["scale_trap_weapon"].length > 1

if script.vars[1] =~ /buy/
	check_locksmiths_container.call
	wait_until { putty_remaining }
	wait_until { cotton_remaining }
	start_script "sorter" if start_sorter
	if putty_remaining >= 100 && cotton_remaining >= 100
		echo "You already have 100 each of putty and cotton balls."
		exit
	else
		if Wounds.lhand >= 3 || Wounds.rhand >= 3 || Wounds.larm >= 3 || Wounds.rarm >= 3 || Scars.lhand >= 3 || Scars.rhand >= 3 || Scars.larm >= 3 || Scars.rarm >= 3 
			echo "Your wounds are too great to do this task. You can't have a missing hand or arm to do this."
			exit
		else
			stow_right.call
			stow_left.call
			fill_up_locksmith_container.call
		end
	end
	exit
end

if script.vars[1] =~ /repair/ && Char.prof =~ /Rogue/
	stow_right.call
	stow_left.call
	lockpicks_to_check = [
		"#{$copper_lockpick_id}",
		"#{$steel_lockpick_id}",
		"#{$gold_lockpick_id}",
		"#{$silver_lockpick_id}",
		"#{$mithril_lockpick_id}",
		"#{$ora_lockpick_id}",
		"#{$laje_lockpick_id}",
		"#{$vultite_lockpick_id}",
		"#{$rolaren_lockpick_id}",
		"#{$veniom_lockpick_id}",
		"#{$invar_lockpick_id}",
		"#{$alum_lockpick_id}",
		"#{$golvern_lockpick_id}",
		"#{$kelyn_lockpick_id}",
		"#{$vaalin_lockpick_id}"
	]
	number = 1
	if $tpick_vaalin_wire == nil
		get_wire_order_numbers.call
	end
	lockpicks_to_check.each { |i|
		result = dothistimeout "look ##{i}", 1, /The.*appears to be broken\.|You see nothing unusual\.|I could not find what you were referring to\./
		if result =~ /The.*appears to be broken\./
			if number == 1
				lockpick_type = "copper"
				current_wire = $tpick_copper_wire
				current_wire_cost = $tpick_copper_wire_cost
			elsif number == 2
				lockpick_type = "steel"
				current_wire = $tpick_steel_wire
				current_wire_cost = $tpick_steel_wire_cost
			elsif number == 3
				lockpick_type = "gold"
				current_wire = $tpick_gold_wire
				current_wire_cost = $tpick_gold_wire_cost
			elsif number == 4
				lockpick_type = "silver"
				current_wire = $tpick_silver_wire
				current_wire_cost = $tpick_silver_wire_cost
			elsif number == 5
				lockpick_type = "mithril"
				current_wire = $tpick_mithril_wire 
				current_wire_cost = $tpick_mithril_wire_cost
			elsif number == 6
				lockpick_type = "ora"
				current_wire = $tpick_ora_wire 
				current_wire_cost = $tpick_ora_wire_cost 
			elsif number == 7
				lockpick_type = "laje"
				current_wire = $tpick_laje_wire
				current_wire_cost = $tpick_laje_wire_cost
			elsif number == 8
				lockpick_type = "vultite"
				current_wire = $tpick_vultite_wire
				current_wire_cost = $tpick_vultite_wire_cost
			elsif number == 9
				lockpick_type = "rolaren"
				current_wire = $tpick_rolaren_wire
				current_wire_cost = $tpick_rolaren_wire_cost
			elsif number == 10
				lockpick_type = "veniom"
				current_wire = $tpick_veniom_wire
				current_wire_cost = $tpick_veniom_wire_cost
			elsif number == 11
				lockpick_type = "invar"
				current_wire = $tpick_invar_wire
				current_wire_cost = $tpick_invar_wire_cost
			elsif number == 12
				lockpick_type = "alum"
				current_wire = $tpick_alum_wire
				current_wire_cost = $tpick_alum_wire_cost
			elsif number == 13
				lockpick_type = "golvern"
				current_wire = $tpick_golvern_wire
				current_wire_cost = $tpick_golvern_wire_cost
			elsif number == 14
				lockpick_type = "kelyn"
				current_wire = $tpick_kelyn_wire
				current_wire_cost = $tpick_kelyn_wire_cost
			elsif number == 15
				lockpick_type = "vaalin"
				current_wire = $tpick_vaalin_wire
				current_wire_cost = $tpick_vaalin_wire_cost
			end
			current_pick_to_check = i
			fput "get ##{current_pick_to_check}"
			move 'out' if checkpaths 'out'
			start_script 'go2', [ 'bank', '--disable-confirm' ]
			wait_while{ running?('go2') }
			multifput "depo all", "withdraw #{current_wire_cost} silvers"
			target_room = Room.current.find_nearest(toolbenches_room_number)
			start_script 'go2', [ target_room.to_s ]
			wait_while{ running?('go2') }
			move 'go toolbench'
			waitrt?
			fput "order #{current_wire}"
			fput "buy"
			waitrt?
			result = dothistimeout "lmas repair ##{current_pick_to_check}", 2, /cooling rapidly to form a tight bond|but the broken tip refuses to work free/
			if result =~ /cooling rapidly to form a tight bond/
				waitrt?
				fput "put ##{current_pick_to_check} in ##{lockpick_container.id}"
			elsif result =~ /but the broken tip refuses to work free/
				echo "This lockpick cannot be repaired."
				fput "stow ##{current_pick_to_check}"
			elsif result.nil?
				echo "Didn't recognize any game lines."
				exit
			end
		elsif result =~ /You see nothing unusual\.|I could not find what you were referring to\./
			nil
		elsif result.nil?
			nil
		end
		number += 1
	}
	move 'out' if checkpaths 'out'
	exit
elsif script.vars[1] =~ /repair/ && Char.prof !~ /Rogue/
	echo "Only rogues can repair lockpicks."
	exit
end

if locksmiths_container
	check_locksmiths_container.call
	wait_until { putty_remaining }
	wait_until { cotton_remaining }
	wait_until { vials_remaining }
	echo "Putty remaining: #{putty_remaining}"
	echo "Cotton balls remaining: #{cotton_remaining}"
	echo "Vials of acid remaining: #{vials_remaining}"
	start_script "sorter" if start_sorter
end

if (script.vars[1] == "reset" || script.vars[2] == "reset" || script.vars[3] == "reset" || script.vars[4] == "reset" || script.vars[5] == "reset" || script.vars[6] == "reset" || script.vars[7] == "reset" || script.vars[8] == "reset" || script.vars[9] == "reset" || script.vars[10] == "reset")
	reset_math.call
end

if Char.prof =~ /Rogue/
	can_use_calipers = true
	if (UserVars.tpick["trick"] == "spin" or UserVars.tpick["trick"] == "twist" or UserVars.tpick["trick"] == "turn" or UserVars.tpick["trick"] == "twirl" or UserVars.tpick["trick"] == "toss" or UserVars.tpick["trick"] == "bend" or UserVars.tpick["trick"] == "flip")
		do_trick = "lmas ptrick #{UserVars.tpick["trick"]}"
	elsif UserVars.tpick["trick"] == "pick"
		do_trick = "pick"
	else
		(echo "Wrong value for TRICK in settings. Type ;tpick setup and enter spin, twist, turn, twirl, toss, bend, flip or pick for the TRICK setting.";exit)
	end
else
	can_use_calipers = nil
	UserVars.tpick["calibrate"] = "no"
	do_trick = "pick"
end

stow_right.call
stow_left.call
calibrate_count = 0

if Spell[205].known? && UserVars.tpick["always_use_205"] == "yes"
	use_spell_205 = true
end

if Spell[402].known? && UserVars.tpick["always_use_402"] == "yes"
	use_spell_402 = true
end

if Spell[403].known? && UserVars.tpick["always_use_403"] == "yes"
	use_spell_403 = true
end

if Spell[404].known? && UserVars.tpick["always_use_404"] == "yes"
	use_spell_404 = true
end

if Spell[506].known? && UserVars.tpick["always_use_506"] == "yes"
	use_spell_506 = true
end

if Spell[613].known? && UserVars.tpick["always_use_613"] == "yes"
	use_spell_613 = true
end

if Spell[704].known? && UserVars.tpick["always_use_704"] == "yes"
	use_spell_704 = true
end

if Spell[1006].known? && UserVars.tpick["always_use_1006"] == "yes"
	use_spell_1006 = true
end

all_variables_to_check.each{|i|
	if i == "loot"
		ground_loot = true
		wealth_before.call
		wait_until { silver_before }
		break
	end
}

all_variables_to_check.each{|i|
	if i =~ /\d+/ && i !~ /level/i
		minimum_tip_wanted = i.to_i
	end
}

all_variables_to_check.each{|i|
	if i =~ /level(\d+)/i
		max_critter_level = $1.to_i
	end
}

echo "Minimum tip wanted: #{minimum_tip_wanted}" if minimum_tip_wanted > 0
echo "Max level wanted: #{max_critter_level}" if max_critter_level != 10000

all_variables_to_check.each{|i|
	if i =~ /plin/
		open_plinites = true
		break
	end
}

all_variables_to_check.each{|i|
	if i == "v"
		always_use_vaalin = true
		break
	end
}

all_variables_to_check.each{|i|
	if i == "wedge"
		always_use_wedge = true
		break
	end
}

all_variables_to_check.each{|i|
	if i == "c"
		start_with_copper = true
		break
	end
}

if (always_use_vaalin) && (start_with_copper)
	start_with_copper = nil
end

if (Char.prof !~ /Rogue|Bard/) && (start_with_copper == nil)
	always_use_vaalin = true
end

all_variables_to_check.each{|i|
	if i == "bash"
		if open_plinites
			echo "Bash feature cannot be used when opening plinites."
			exit
		end
		bash_open_boxes = true
		break
	end
}

if (bash_open_boxes) && (Char.prof != "Warrior")
	echo "Only warriors can bash boxes."
	exit
end

all_variables_to_check.each{|i|
	if i == "disarm"
		if open_plinites
			echo "Disarm feature cannot be used when opening plinites."
			exit
		end
		disarm_only = true
		break
	end
}

all_variables_to_check.each{|i|
	if i == "relock"
		if open_plinites
			echo "Relock feature cannot be used when opening plinites."
			exit
		end
		relock_boxes = true
		break
	end
}

if (relock_boxes) && (bash_open_boxes)
	echo "\"relock\" and \"bash\" cannot both be used together."
	exit
end

all_variables_to_check.each{|i|
	if i == "pop"
		if open_plinites
			echo "Popping feature cannot be used when opening plinites."
			exit
		end
		popping = true
		break
	end
}

if popping && !Spell[416].known?
	echo "This feature requires the knowledge of Piercing Gaze (416)."
	exit
end

if popping && (UserVars.tpick["always_use_704"].nil? || UserVars.tpick["number_of_416_casts"].nil? || UserVars.tpick["only_disarm_safe"].nil? || UserVars.tpick["always_use_704"].empty? || UserVars.tpick["number_of_416_casts"].empty? || UserVars.tpick["only_disarm_safe"].empty?)
	echo "This feature requires all settings in the Popping tab in setup to be filled out before using."
	exit
end

(cast_205.call) if (use_spell_205) && (Spell[205].known?)

if (script.vars[1] == "ground" || script.vars[2] == "ground" || script.vars[3] == "ground" || script.vars[4] == "ground" || script.vars[5] == "ground" || script.vars[6] == "ground" || script.vars[7] == "ground" || script.vars[8] == "ground" || script.vars[9] == "ground" || script.vars[10] == "ground" || bash_open_boxes)
	if open_plinites
		echo "Ground feature cannot be used when opening plinites."
		exit
	end
	solo_or_other = "ground"
	if (UserVars.tpick["calibrate"] == "yes") && (always_use_vaalin == nil) && (popping == nil) && (can_use_calipers) && (start_with_copper == nil)
		calibrate.call
	end
	start_ground.call
elsif (script.vars[1] == "other" || script.vars[2] == "other" || script.vars[3] == "other" || script.vars[4] == "other" || script.vars[5] == "other" || script.vars[6] == "other" || script.vars[7] == "other" || script.vars[8] == "other" || script.vars[9] == "other" || script.vars[10] == "other")
	if open_plinites
		echo "Other feature cannot be used when opening plinites."
		exit
	end
	if popping
		echo "Popping feature does not work when popping other people's boxes."
		exit
	end
	if (disarm_only) && (bash_open_boxes == nil)
		echo "Disarm only feature only works for ground picking."
		exit
	end
	solo_or_other = "other"
	fput "say #{UserVars.tpick["ready"]}" if UserVars.tpick["ready"] != "nil"
	start_others.call
elsif (script.vars[1] == "worker" || script.vars[2] == "worker" || script.vars[3] == "worker" || script.vars[4] == "worker" || script.vars[5] == "worker" || script.vars[6] == "worker" || script.vars[7] == "worker" || script.vars[8] == "worker" || script.vars[9] == "worker" || script.vars[10] == "worker")
	if open_plinites
		echo "Worker feature cannot be used when opening plinites."
		exit
	end
	if popping
		echo "Popping feature does not work when popping other people's boxes."
		exit
	end
	if (disarm_only) && (bash_open_boxes == nil)
		echo "Disarm only feature only works for ground picking."
		exit
	end
	solo_or_other = "worker"
	start_worker.call
else
	if (disarm_only) && (bash_open_boxes == nil)
		echo "Disarm only feature only works for ground picking."
		exit
	end
	solo_or_other = "solo"
	wealth_before.call
	wait_until { silver_before }
	$tpick_boxes_checked = nil
	check_for_command = "inv full"
	check_for_boxes.call
	wait_until { $tpick_boxes_checked }
	if popping
		pop_start.call
	elsif open_plinites
		start_plinites.call
	else
		if (UserVars.tpick["calibrate"] == "yes") && (always_use_vaalin == nil) && (can_use_calipers) && (start_with_copper == nil)
			calibrate.call
		end
		start_solo.call
	end
end